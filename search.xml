<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>k8s</title>
      <link href="/2020/03/30/xue-xi-pian/kubernetes/"/>
      <url>/2020/03/30/xue-xi-pian/kubernetes/</url>
      
        <content type="html"><![CDATA[<h2 id="Iaas"><a href="#Iaas" class="headerlink" title="Iaas"></a>Iaas</h2><ul><li>infrastructure as a service</li><li>基础设施即服务</li><li>对应计算机的物理机</li><li>比较流行的产品有openstack、VM等</li></ul><h2 id="Paas"><a href="#Paas" class="headerlink" title="Paas"></a>Paas</h2><ul><li>platform as a servie</li><li>平台即服务</li><li>现今业界公认的标准产品是Docker</li><li>针对于Iaas进行上一层的封装</li></ul><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><ul><li><p>将环境容器化</p><ul><li>带来的问题是容器与外界访问被容器本身封装了一层，需要增加容器端口和物理机端口的资源映射完成和外界通信，效率变低</li></ul></li><li><p>安装</p><ol><li>SET UP THE REPOSITORY<ul><li>yum install -y yum-utils device-mapper-persistent-data lvm2</li></ul></li><li>替换yum的docker源<ul><li>wget <a href="https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo" target="_blank" rel="noopener">https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</a> -O /etc/yum.repos.d/docker-ce.repo</li></ul></li><li>INSTALL DOCKER ENGINE - COMMUNITY<ul><li>yum install docker-ce docker-ce-cli containerd.io</li></ul></li><li>镜像加速器<ul><li><a href="https://cr.console.aliyun.com/" target="_blank" rel="noopener">https://cr.console.aliyun.com/</a><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">mkdir</span> -p /etc/docker<span class="token function">sudo</span> <span class="token function">tee</span> /etc/docker/daemon.json <span class="token operator">&lt;&lt;</span>-<span class="token string">'EOF'</span><span class="token punctuation">{</span><span class="token string">"registry-mirrors"</span><span class="token keyword">:</span> <span class="token punctuation">[</span><span class="token string">"https://7som5skl.mirror.aliyuncs.com"</span><span class="token punctuation">]</span><span class="token punctuation">}</span>EOF<span class="token function">sudo</span> systemctl daemon-reload<span class="token function">sudo</span> systemctl restart docker</code></pre></li></ul></li></ol></li><li><p>搭建本地私服</p><ul><li><p>docker run -d -p 5000:5000 –restart always –name registry registry:2</p><ol><li>docker pull registry</li><li>docker run -d -p 5000:5000 –restart always –name registry</li><li>docker tag ubuntu localhost:5000/ubuntu:v1</li><li>docker push localhost:5000/ubuntu:v1</li><li>docker pull localhost:5000/ubuntu:v1</li></ol></li><li><p>设置私服访问权限</p><pre class=" language-bash"><code class="language-bash">  <span class="token comment" spellcheck="true">## 创建目录</span>  <span class="token function">mkdir</span> -p /data/DockerRegistry/<span class="token punctuation">{</span>Data,Cert,Auth<span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">## 生成TLS使用的自签名证书</span>  <span class="token function">cd</span> /data/DockerRegistry/Cert  domain<span class="token operator">=</span>MyDockerRegistry.com  openssl req -nodes \  -subj <span class="token string">"/C=CN/ST=Hubei/L=Wuhan/CN=<span class="token variable">$domain</span>"</span> \  -newkey rsa:4096 -keyout <span class="token variable">$domain</span>.key -out <span class="token variable">$domain</span>.csr  openssl x509 -req -days 3650 -in <span class="token variable">$domain</span>.csr -signkey <span class="token variable">$domain</span>.key -out <span class="token variable">$domain</span>.crt  <span class="token comment" spellcheck="true">## 生成鉴权使用的密码文件</span>  docker run --name once --entrypoint<span class="token operator">=</span>htpasswd registry:2 -Bbn docker docker666 <span class="token operator">></span> /data/DockerRegistry/Auth/Htpasswd  docker <span class="token function">rm</span> once  <span class="token comment" spellcheck="true">## 运行容器</span>  docker run -d \  -p 5000:5000 \  --restart<span class="token operator">=</span>always \  --name registry \  -v /data/DockerRegistry/Data:/var/lib/registry \  -v /data/DockerRegistry/Cert:/Cert \  -v /data/DockerRegistry/Auth:/Auth \  -e <span class="token string">"REGISTRY_AUTH=htpasswd"</span> \  -e <span class="token string">"REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm"</span> \  -e REGISTRY_AUTH_HTPASSWD_PATH<span class="token operator">=</span>/Auth/Htpasswd \  -v <span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">pwd</span><span class="token variable">)</span></span>"</span>/certs:/certs \  -e REGISTRY_HTTP_TLS_CERTIFICATE<span class="token operator">=</span>/Cert/MyDockerRegistry.com.crt \  -e REGISTRY_HTTP_TLS_KEY<span class="token operator">=</span>/Cert/MyDockerRegistry.com.key \  registry:2  <span class="token comment" spellcheck="true">## 配置域名</span>  <span class="token keyword">echo</span> <span class="token string">"127.0.0.1 MyDockerRegistry.com"</span> <span class="token operator">>></span> /etc/hosts  <span class="token comment" spellcheck="true">## 查看docker registry中的镜像</span>  curl https://MyDockerRegistry.com:5000/v2/_catalog -u docker:docker666 --cacert /data/DockerRegistry/Cert/MyDockerRegistry.com.crt</code></pre></li></ul></li><li><p>发布镜像到阿里私服</p><ul><li><p>docker login –username=99allnice registry.cn-chengdu.aliyuncs.com</p></li><li><p>docker tag [ImageId] registry.cn-chengdu.aliyuncs.com/allnice/99:[镜像版本号]</p></li><li><p>docker push registry.cn-chengdu.aliyuncs.com/allnice/99:[镜像版本号]</p><p>docker exec -it registry  /bin/registry garbage-collect  /etc/docker/registry/config.yml</p></li></ul></li></ul><h3 id="k8s"><a href="#k8s" class="headerlink" title="k8s"></a>k8s</h3><ul><li>分布式资源管理框架</li><li>优点<ul><li>开源</li><li>弹性伸缩</li><li>轻量级</li><li>负载均衡：ipvs策略</li></ul></li><li>前身<ul><li>google borg框架的go语言版本</li></ul></li><li>组件<ul><li>master<ul><li>kubectl：命令终端</li><li>web UI：页面控制台</li><li>scheduler：调度中心，选择合适的node完成任务分配</li><li>controller：控制中心，维护副本期望数目<ul><li>replication controller</li><li>replicaSet controller<ul><li>支持HPA（horizontal pod autoscale），通过配置条件自动扩缩容</li></ul></li><li>deployment controller<ul><li>支持HPA</li></ul></li><li>高可用集群副本数目最好是大于1的奇数，原因同zookeeper选举机制，大于半数策略</li><li>新版本中增加了replicaSet，该控制器支持组合式操作pod，比如通过pod的别名+pod版本来操作pod，RC不支持组合式</li><li>滚动更新则需要使用deployment控制器，原理是它会生成RS来创建pod，如果需要更新pod版本，则会创建新的RS_NEW来创建新的pod，同时废弃旧版本的pod</li><li>statefullSet<ul><li>解决有状态服务问题</li><li>稳定的持久化存储<ul><li>pod重新调度后能访问相同的持久化数据，基于PVC实现</li></ul></li><li>稳定的网络标志<ul><li>pod重新调度后能保持原有的podname和hostname等，基于Headless Service</li></ul></li><li>有序部署</li><li>有序收缩</li></ul></li><li>daemonSet<ul><li>确保全部或部分node上运行一个pod副本</li><li>当有node加入则自动创建pod，node移除会自动销毁pod</li><li>daemonset被删除时，会自动删除它所创建的所有pod</li></ul></li><li>job，cronjob</li></ul></li><li>api server：服务中心，所有服务访问的统一入口</li><li>etcd：k-v分布式存储服务</li></ul></li><li>node<ul><li>kubelet：与cri（container runtime interface）交互，维持pod的生命周期</li><li>kube proxy：写入规则到iptables、ipvs，负责pod的负载均衡，主要是与防火墙交互进行映射处理<ul><li>firewall</li></ul></li><li>pod<ul><li>container：主流的docker</li><li>自主式pod</li><li>被控制管理的pod</li><li>同一个pod中的各个容器交互<ul><li>io</li><li>公用pause网络栈，通过localhost就可以相互访问</li></ul></li><li>pod和pod的交互<ul><li>overlay network<ul><li>flannel开源产品实现</li></ul></li><li>1:1或N:1<ul><li>k8s自身就支持</li></ul></li><li>1:N或N:N<ul><li>可以通过SVC（service）桥接来实现</li></ul></li></ul></li><li>pod与svc交互<ul><li>iptables或ipvs</li></ul></li></ul></li></ul></li></ul></li><li>插件<ul><li>coreDNS：可以为集群中的svc创建域名ip关系解析</li><li>dashboard：为k8s提供一个B/S的访问模式</li><li>ingress controller：官方只能提供4层代理，它可以提供7层</li><li>fedetation：提供一个可以跨集群中心多k8s统一管理功能</li><li>prometheus：提供k8s监控能力</li><li>ELK：提供k8s日志统一分析接入平台</li></ul></li></ul><h2 id="Saas"><a href="#Saas" class="headerlink" title="Saas"></a>Saas</h2><ul><li>software as a service</li><li>软件即服务</li><li></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云服务器</title>
      <link href="/2020/03/21/xue-xi-pian/yun-fu-wu-qi/"/>
      <url>/2020/03/21/xue-xi-pian/yun-fu-wu-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="云服务器厂商"><a href="#云服务器厂商" class="headerlink" title="云服务器厂商"></a>云服务器厂商</h2><ul><li>阿里云</li><li>腾讯云</li><li>UCloud</li><li>GCP，谷歌云</li></ul><h2 id="云机器相关"><a href="#云机器相关" class="headerlink" title="云机器相关"></a>云机器相关</h2><ul><li>ECS<ul><li>elastic compute service<ul><li>简单高效，处理能力可伸缩计算服务</li><li>与传统服务器IDC区别</li></ul></li></ul></li><li>VPS<ul><li>Virtual Private Server<ul><li>虚拟专用服务器</li></ul></li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> ECS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue</title>
      <link href="/2020/03/20/xue-xi-pian/vue/"/>
      <url>/2020/03/20/xue-xi-pian/vue/</url>
      
        <content type="html"><![CDATA[<h2 id="组件化和模块化"><a href="#组件化和模块化" class="headerlink" title="组件化和模块化"></a>组件化和模块化</h2><ol><li>组件化是根据UI的角度进行内容拆分</li><li>模块化是根据逻辑的角度进行内容拆分</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css</title>
      <link href="/2020/03/16/zhuan-ye-pian/css/"/>
      <url>/2020/03/16/zhuan-ye-pian/css/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>Cascading Style Sheets</li><li>层叠样式表</li></ul><h3 id="块元素和内联元素"><a href="#块元素和内联元素" class="headerlink" title="块元素和内联元素"></a>块元素和内联元素</h3><ul><li>通常用块元素包含内联元素</li><li>块元素<ul><li>为页面布局</li><li>会独占一行<ul><li>div，没有任何语义，没有任何默认样式，用来布局</li><li>p，不能包含任何其他块元素</li><li>h1</li></ul></li></ul></li><li>内联元素<ul><li>为文本做样式</li><li>只占自身大小，不会独占一行<ul><li>span，为元素或文字设置样式</li><li>a，可以包含任何元素，不能包含自身</li></ul></li></ul></li></ul><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><ul><li>元素选择器</li><li>属性选择器</li><li>class选择器</li><li>*通配选择器</li><li>并集选择器</li><li>交集选择器</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pdman</title>
      <link href="/2020/02/17/zhuan-ye-pian/pdman/"/>
      <url>/2020/02/17/zhuan-ye-pian/pdman/</url>
      
        <content type="html"><![CDATA[<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><ul><li><code>cnpm run start</code></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> db </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程</title>
      <link href="/2020/01/28/xue-xi-pian/duo-xian-cheng/"/>
      <url>/2020/01/28/xue-xi-pian/duo-xian-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="多进程vs多线程"><a href="#多进程vs多线程" class="headerlink" title="多进程vs多线程"></a>多进程vs多线程</h2><ol><li>创建进程开销大于线程</li><li>进程间通信比线程慢</li><li>多进程比多线程稳定</li></ol><h2 id="java线程"><a href="#java线程" class="headerlink" title="java线程"></a>java线程</h2><ul><li>Thread.setPriority:设置优先级，默认5，1~10</li><li>Thread.join()，等待Thread线程结束运行后当前进程继续运行</li><li>isInterrupted(),用来判断是否有其他线程调用了当前线程的interrupt()方法来中断当前线程<ul><li>也可以通过volatile变量来控制</li></ul></li><li>Thread.setDaemon(true)，创建守护线程，为其他线程服务，非守护线程运行结束后和jvm进程一起退出</li><li>Thread.wait()，只能在同步代码块中调用，会马上释放当前锁资源，等待其他线程调用锁对象的notify进行唤醒</li><li>状态<ul><li>New（创建）</li><li>Runable（运行中）</li><li>Blocked（阻塞）</li><li>Waiting（等待）</li><li>Timed Waiting（计时等待）</li><li>Terminated（已终止）</li></ul></li><li>线程安全的类</li></ul><ol><li>不变类：String、Integer、LocalDate</li><li>没有成员变量的类：Math</li><li>正确使用synchronized的类：StringBuffer<ul><li>synchronize的方法加锁的是当前对象实例：this</li><li>synchronize无法进行线程协调工作</li></ul></li></ol><ul><li><p>死锁</p><ul><li>各自拥有不同的锁，且都等待对方释放锁</li><li>避免死锁：各自任务持有不同锁的顺序必须一致</li></ul></li><li><p>reentranklock替换synchronize进行开启释放锁</p></li><li><p>reentrankreadwriteloca</p><ul><li>读写锁分离，可以提高读效率，适用于多读少写场景</li></ul></li><li><p>condition.awiat/signal/signalall === wait/notify/notifyall</p></li><li><p>concurrent集合<br><img src="/imgs/threadsafelist.png" alt=""></p></li><li><p>Atomic</p><ul><li>CAS(compare and set)<ul><li>会存在ABA问题，可以通过乐观锁来规避，正常情况不需要考虑</li></ul></li><li>实现无锁的线程安全</li><li>适用于累加器，计数器</li></ul></li><li><p>ExcuteService</p><ul><li>线程池</li></ul></li><li><p>ScheduledExcuteService</p><ul><li>FixRate，周期执行，不管执行的任务是否完成，会周期性开启线程执行任务</li><li>FixDelay，任务执行完后间隔周期性时间执行下一个</li></ul></li><li><p>Callable等同Runnable</p><ul><li>callable：需要返回结果</li><li>Runnable：不需要返回结果</li><li>配合Future来使用</li></ul></li><li><p>CompletableFuture</p><ol><li>异步任务结束时，会自动调用某个对象方法</li><li>异步任务出错时，会自动调用某个对象方法</li><li>主线程设置好回调后，不用关心异步任务的执行</li></ol><ul><li>thenAccept():处理正常结果</li><li>exceptional():处理异常结果</li><li>thenApplyAsync():串行化另一个异步任务</li><li>anyOf/allOf:并行处理多个CompletableFuture</li></ul></li><li><p>ThreadLocal</p><ul><li>线程内传递状态<ul><li>空间换时间，会按照线程维度生成各自的变量</li></ul></li><li>jdk8之后的实现方式是线程绑定threadlocalmap<ul><li>threadlocalmap&lt;ThreadLocal&lt;?&gt; extends WeakReference, value&gt;中的key是弱引用类型</li><li>目的是为了当threadlocal使用结束后会gc会回收只有弱引用的对象，让key为null，当下次用到threadlocalmap中的接口时jvm会判断key为null的entry对应的将value置为null，来防止内存泄漏</li></ul></li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>netty</title>
      <link href="/2020/01/13/xue-xi-pian/netty/"/>
      <url>/2020/01/13/xue-xi-pian/netty/</url>
      
        <content type="html"><![CDATA[<p>deploy-web-161.sh</p><h2 id="netty"><a href="#netty" class="headerlink" title="netty"></a>netty</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul><li>异步</li><li>事件驱动</li><li>零拷贝</li></ul><h4 id="netty组件"><a href="#netty组件" class="headerlink" title="netty组件"></a>netty组件</h4><ul><li>bossGroup：接收连接线程组，netty管理</li><li>workerGroup：I/O线程组，netty管理</li><li>channelhandler<ul><li>入站处理器：ChannelInboundHandler</li><li>出站处理器：ChannelOutboundHandler</li><li>编解码都是channelhandler</li><li>codec：编解码<ul><li>编码：本质上是出站处理器<ul><li>将数据由原本的格式转换为字节流</li><li>MessageToByteEncoder</li></ul></li><li>解码：本质上是入站处理器<ul><li>将字节流转换成原本格式或其他格式</li><li>ByteToMessageDecoder/ReplayingDecoder</li></ul></li></ul></li></ul></li><li>ChannelInitializer<ul><li>通道事件处理链初始化</li><li>通过ChannelPipeline进行事件链的添加</li></ul></li><li>ServerBootstrap<ul><li>服务端配置类，简化服务启动需要初始化的内容</li><li>channel():通道类型设置</li><li>handle():通道事件链设置，对应于bossGroup管理</li><li>childHandle():通道事件链设置，对应于workerGroup管理</li><li>option():ChannelOption，通道可选项配置</li></ul></li><li>Bootstrap<ul><li>客户端配置类，参考服务端</li></ul></li><li>bytebuf<ul><li><img src="/imgs/bytebuf%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt=""></li><li>3种类型<ol><li>heap buffer：堆上缓存区<ul><li>优点：数据在jvm中，所以可以快速创建释放，并且提供了内部访问方法，数据被存放在byte array上</li><li>缺点：每次信息交互，都需要拷贝到直接缓存区进行网络等交互</li></ul></li><li>direct buffer：直接缓存区<ul><li>优点：socket数据交互时，性能更优，</li><li>缺点：由操作系统控制缓存的创建和释放，比堆上处理更复杂和耗时，不支持byte array方式来访问</li><li>netty中通过使用内存池来优化缺点暴露的问题</li></ul></li><li>composite buffer：复合缓存区<ul><li>可以放入heap buffer和direct buffer混合，通过组件（Component）方式加入</li></ul></li></ol></li><li>类型选择：<ol><li>对于后端业务消息编解码，建议使用heap buffer</li><li>对于I/O通信线程在读写缓存区时，建议使用derect buffer</li></ol></li><li>与jdk bytebuffer比较<ul><li>jdk bytebuffer<ul><li>缺点：final byte[]，jdk中声明后就不能动态伸缩；只有一个position指针标识位置信息，读写切换需要flip或者rewind来重置指针</li></ul></li><li>bytebuf<ul><li>优点：声明的数组是支持动态扩容的，默认最大容量Integer.MAX_VALUE，动态性体现在write方法中，不足则自动扩容；读写是完全独立的</li></ul></li></ul></li></ul></li><li>AtomicIntegerFieldUpdater：原子int更新器<ol><li>更新器更新的类型必须是int，不能是其包装类型即Integer</li><li>更新的类型必须是volatile，保证不被重排序和线程间的可见性</li><li>变量不能是static，因为底层用的是Unsafe.objectFieldOffset()方法来更新（CAS本质上通过实例的偏移量直接复制）</li><li>更新器只能修改可见范围内的变量</li></ol><ul><li>netty中为何没有用AtomicInteger，netty中bytebuf用的数量特别大，如果每个bytebuf都内置一个AtomicInteger会造成一定的性能开销，通过统一的Updater可以全局设置一个，从而降低开销</li></ul></li><li>TCP粘包和拆包<ul><li>粘包：客户端发送的多次消息，服务端无法区分，导致多条消息可能按照不同组合方式粘在一起，反之亦然</li><li>拆包：客户端发送的单次长消息，服务端可能拆分为多条，导致拆包异常，反之亦然</li><li>通过codec来处理，如modbus协议的数据等</li></ul></li><li>小结<ol><li>一个EventLoopGroup包含一个或多个EventLoop</li><li>一个EventLoop生命周期只会关联一个Thread</li><li>所有由EventLoop处理的I/O事件都在关联的那个Thread进行</li><li>一个channel的整个生命周期只会注册一个EventLoop</li><li>一个EventLoop生命周期过程中，会被分配给一个或多个channel</li><li>channel的实现是线程安全的，用来保证channel的任务按照顺序提交到EventLoop，并将消息顺序发出</li><li>在开发中，不要将执行耗时的任务丢到EventLoop中执行，会影响netty的IO线程执行效率，可通过以下2种方式实现<ol><li>在channelHandle回调方法中，将这些任务丢给业务线程池，实现业务的异步处理</li><li>借助于netty提供的向channelpipeline的addLast方法传递EventExecutor<ul><li>说明：默认情况下，channelpipeline中绑定的channelHandle都是有I/O线程组执行，但是调用了首个入参是EventExecutorGroup的方法，则channelHandle中的回调方法则有参数中的线程组异步执行</li></ul></li></ol></li><li>发送消息方式<ol><li>通过channel-消息会经过channelpipeline的最后一个handle到第一个依次流转</li><li>通过channelhandlecontext-从当前channelhandle的下一个handle流转，效率更高</li></ol></li></ol></li></ul><h3 id="HTTP服务器"><a href="#HTTP服务器" class="headerlink" title="HTTP服务器"></a>HTTP服务器</h3><h3 id="socket开发（RPC）"><a href="#socket开发（RPC）" class="headerlink" title="socket开发（RPC）"></a>socket开发（RPC）</h3><ul><li>RPC<ul><li>remote proceduce call：远程过程调用</li></ul><ol><li>定义接口说明文件（idl）：描述对象（结构体）、对象成员、接口方法等一系列信息</li><li>通过RPC框架所提供的编译器，将接口说明文件生成对应的语言文件</li><li>客户端和服务端分别引入RPC编译生成的文件，即可以像调用本地方法一样调用远程方法，底层是基于socket通信</li></ol></li><li>webservice<ul><li>基于http，效率没有socket高</li></ul></li><li>client<ul><li>stub 桩</li></ul></li><li>server<ul><li>skeleton 骨架</li></ul></li><li>序列化与反序列化：编码与解码</li><li>rmi：只适用于java<ul><li>remote method invocation</li></ul></li></ul><h4 id="apache的thift"><a href="#apache的thift" class="headerlink" title="apache的thift"></a>apache的thift</h4><ul><li>IDL:interface definition languague</li><li>安装编译工具<ul><li><code>$ brew install thrift</code></li></ul></li><li>generate code<ul><li><code>$ thrift --gen &lt;language&gt; &lt;Thrift filename&gt;</code></li></ul></li><li>通信三要素<ol><li>协议<ul><li>thrift</li></ul></li><li>通信格式<ul><li>TProtocol的实现，如：TBinaryProtocol-二进制格式，TCompactProtocol-压缩格式等</li></ul></li><li>数据格式<ul><li>自定义</li></ul></li></ol></li><li>thrift传输模式<ul><li>TTransport的实现，如：TSocket-阻塞式等</li></ul></li><li>thrift服务模型<ul><li>基于对socket的封装</li><li>TServer的实现，如：TNonblockingServer-非阻塞，多线程模型等</li></ul></li></ul><h4 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h4><ul><li>google protobuf</li><li><h2 id="安装编译工具"><a href="#安装编译工具" class="headerlink" title="安装编译工具"></a>安装编译工具</h2></li></ul><h3 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h3><ul><li>全双工通信协议，长连接</li></ul><h3 id="io体系"><a href="#io体系" class="headerlink" title="io体系"></a>io体系</h3><h4 id="java-io"><a href="#java-io" class="headerlink" title="java.io"></a>java.io</h4><ul><li>流<ul><li>输入流：从外部到程序<ul><li>字节：inputstream</li><li>字符：read</li></ul></li><li>输出流：从程序到外部<ul><li>字节：outputstream</li><li>字符：write</li></ul></li><li>字节流：最底层的流实现</li><li>字符流：基于字节流做的封装</li><li>节点流<ul><li>从特定的地方读写的流类，磁盘或者内存</li></ul></li><li>过滤流<ul><li>使用节点流作为输入输出，然后连接节点流</li></ul></li></ul></li></ul><h4 id="java-nio"><a href="#java-nio" class="headerlink" title="java.nio"></a>java.nio</h4><ul><li>块/buffer<ul><li>selector</li><li>channel：类似于java.io中的stream</li><li>buffer：基于数组的数据结构实现，所有读写都是通过buffer，不会通过channel<ul><li>0 &lt;= mark &lt;= positon &lt;= limit &lt;= capacity </li><li>mark：标记的元素索引</li><li>position：待操作数组元素的定位</li><li>limit：buffer数组可操作的长度</li><li>capacity：常量，buffer数组申请的总长度</li></ul></li></ul></li><li>零拷贝zero copy<ul><li><img src="/imgs/nio%E9%9B%B6%E6%8B%B7%E8%B4%9D01.png" alt=""></li><li><img src="/imgs/nio%E9%9B%B6%E6%8B%B7%E8%B4%9D02.png" alt=""></li><li><img src="/imgs/nio%E9%9B%B6%E6%8B%B7%E8%B4%9D03.png" alt=""></li><li><img src="/imgs/nio%E9%9B%B6%E6%8B%B7%E8%B4%9D04.png" alt=""></li><li>DMA:direct memory access</li></ul></li></ul><h4 id="java编解码"><a href="#java编解码" class="headerlink" title="java编解码"></a>java编解码</h4><ul><li>decode<ul><li>将信息解码成char</li></ul></li><li>encode<ul><li>将char编码成byte</li></ul></li><li>ASCII<ul><li>American Standard Code For Information Interchange-美国信息交换标准代码</li><li>7bit表示一个字符，可以表示128种字符</li></ul></li><li>IOS-8859-1<ul><li>8bit，一个byte，来表示一个字符，可以表示256种字符，包含128种ASCII所表示的字符</li></ul></li><li>GB2312国标编码<ul><li>2个字节表示一个汉字</li></ul></li><li>GBK<ul><li>包含GB2312</li></ul></li><li>GB18030<ul><li>包含GBK，最全的国标编码</li></ul></li><li>big5<ul><li>台湾繁体编码</li></ul></li><li>unicode<ul><li>包含全球所有国家的语言的编码</li><li>采用2个字节（byte）表示一个字符</li></ul></li><li>UTF<ul><li>Unicode Translation Format</li><li>是一种存储方式</li><li>utf-8是unicode的实现之一，一般用1个字节表示英文，3个字节表示中文</li></ul></li></ul><h4 id="reactor模式"><a href="#reactor模式" class="headerlink" title="reactor模式"></a>reactor模式</h4><ul><li>scalable IO in java</li><li>与传统模式比较<ul><li>传统模式<ul><li>缺点<ol><li>一个socket一个线程</li><li>多线程的上下文切换性能开销</li><li>socket建立之后不会实时交互信息，导致空置线程</li></ol></li><li>优点<ol><li>易于编程</li></ol></li></ul></li><li>reactor模式<ul><li><img src="/imgs/reactor%E6%A8%A1%E5%9E%8B01.png" alt=""></li><li>角色构成<ol><li>Handle（句柄或描述符）：表示的是一种资源，是由操作系统来提供的，表示一个个事件，事件产生的发源地。</li><li>Synchronous Event Demultiplexer（同步事件分离器）：用于等待事件发生，调用方在调用的时候被阻塞，一直等待有事件发生为止，对于linux来说，它指的是常用的I/O复用机制，如：select，poll，epoll等。同java nio中的selector。</li><li>Event Handle（事件处理器）：本身由多个回调方法组成，这些回调方法构成了事件触发的反馈机制。</li><li>Concrete Event Handle（具体事件处理器）：是事件处理的实现，由开发自定义。</li><li>Initiation Dispatcher（初始分发器）：实际上就是reactor角色，本身定义了一些规范，用于控制事件的调度方式，同时提供了应用进行事件处理器的注册、删除等操作。</li></ol></li><li>acceptor:用于主reactor到从reactor转移注册信息</li></ul></li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PLC</title>
      <link href="/2020/01/08/xue-xi-pian/dian-zi-tong-xin/"/>
      <url>/2020/01/08/xue-xi-pian/dian-zi-tong-xin/</url>
      
        <content type="html"><![CDATA[<h2 id="通信基础"><a href="#通信基础" class="headerlink" title="通信基础"></a>通信基础</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ul><li>基带和频带</li><li><h2 id="通信协议3要素"><a href="#通信协议3要素" class="headerlink" title="通信协议3要素"></a>通信协议3要素</h2><h3 id="通信接口标准"><a href="#通信接口标准" class="headerlink" title="通信接口标准"></a>通信接口标准</h3></li><li>RS232</li><li>RS422</li><li>RS485</li></ul><h3 id="通信格式"><a href="#通信格式" class="headerlink" title="通信格式"></a>通信格式</h3><ul><li>对一个字符的通信格式定义</li><li>波特率</li><li>奇偶校验位</li><li>起始位</li><li>数据位</li><li>停止位个数</li><li>7E1<ul><li>数据区7个，E：偶校验，停止位1个</li></ul></li><li>8E2</li></ul><h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><ul><li>帧<ul><li>一个完整的信息成为一帧</li><li>帧传送是一个字符一个字符可以间隔发送，每个字符是从低位到高位一位一位连续发送</li></ul></li><li>HDLC（高级数据链路控制）数据格式标准<ul><li>起始码：信息帧的起始边界</li><li>地址码：设备在网络中的站址</li><li>控制码：方法，表示做什么</li><li>信息码：入参，表示怎么做</li><li>校验码：对参与校验的数据进行校验所形成的码</li><li>停止码：信息帧的结束边界</li></ul></li></ul><h3 id="MODBUS通信协议"><a href="#MODBUS通信协议" class="headerlink" title="MODBUS通信协议"></a>MODBUS通信协议</h3><ul><li>基于RS485总线协议</li><li>主从式串行异步半双工通信协议<ul><li>主站可以和从站双向通信，从站之间不能直接通信，一个时刻主站只能和一个从站通信</li><li>广播方式可以实现主站和所有从站同时通信，不过不能收到从站回应</li></ul></li><li>数据格式<ul><li>起始码：固定</li><li>地址码：固定</li><li>功能码：固定<ul><li><table><thead><tr><th>功能码</th><th>名称</th><th>功能</th></tr></thead><tbody><tr><td>H01</td><td>读线圈状态</td><td>取输出开关量状态</td></tr><tr><td>H02</td><td>读输入状态</td><td>取输入开关量状态</td></tr><tr><td>H03</td><td>读保持存储器</td><td>读一个或多个输出存储器值</td></tr><tr><td>H04</td><td>读存储器</td><td>读一个或多个输入存储器值</td></tr><tr><td>H05</td><td>强置单线圈</td><td>强置一个输出开关量状态</td></tr><tr><td>H06</td><td>写保持存储器</td><td>把字写入一个输出</td></tr><tr><td>H08</td><td>回送诊断校验</td><td>取输出开关量状态</td></tr><tr><td>H0F</td><td></td><td>强置单线圈</td></tr><tr><td>H10</td><td>预置多存储器</td><td>取输出开关量状态</td></tr></tbody></table></li></ul></li><li>数据区：格式不可选，字址定义可选</li><li>校验码：固定</li><li>停止码：固定</li></ul></li></ul><h4 id="4大模式"><a href="#4大模式" class="headerlink" title="4大模式"></a>4大模式</h4><ul><li><p>ASCII模式</p><ul><li>通信格式<ul><li>起始位：1位</li><li>数据长度：7位，低位先送</li><li>校验位：1位（有检验），0位（无校验）</li><li>停止位：1位（有检验），2位（无校验）</li><li>波特率：可选</li></ul></li><li>数据格式<ul><li>校验方式：LRC算法<ul><li>从地址码~数据区H进制数累加后求补码获得校验码</li></ul></li></ul></li><li>应用<ul><li>通信格式<ul><li>正常情况是先设置变频器然后根据设置的信息转义成格式字存储到PLC上，但是有些情况是PLC某些格式字固定了，就需要反向来处理，大部分情况PLC比变频器灵活</li><li>PLC通信格式字设置</li><li>变频器通信参数设置</li></ul></li></ul></li></ul></li><li><p>RTU模式</p><ul><li>通信格式<ul><li>起始位：1位</li><li>数据长度：8位，低位先送</li><li>校验位：1位（有检验），0位（无校验）</li><li>停止位：1位（有检验），2位（无校验）</li><li>波特率：可选</li></ul></li><li>数据格式<ul><li><img src="/imgs/RTU%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F.png" alt=""></li><li>校验方式：CRC算法<ul><li>二进制异或运算，相同位0，不同位1</li></ul></li></ul></li><li>数据传送约定<ul><li>帧信息连续发送，如果出现发送过程中1.5个字符的禁止时间则信息会出现错误</li></ul></li><li>主站查询，从站应答<ul><li><img src="/imgs/MODBUS%E5%8A%9F%E8%83%BD%E7%A0%81%E5%BA%94%E7%AD%94.png" alt=""></li><li>错误应答协议：功能码的最高为置为1</li></ul></li></ul></li><li><p>TCP</p></li><li><p>UDP</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> plc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>maven</title>
      <link href="/2020/01/06/zhuan-ye-pian/maven/"/>
      <url>/2020/01/06/zhuan-ye-pian/maven/</url>
      
        <content type="html"><![CDATA[<h2 id="maven依赖管理2中方式"><a href="#maven依赖管理2中方式" class="headerlink" title="maven依赖管理2中方式"></a>maven依赖管理2中方式</h2><ol><li>import pom<ul><li>只能作用于dependencyMannagement</li><li>pluginManagement不能继承，需要单独在项目父pom中声明</li></ul></li><li>parent<ul><li>可以全部继承</li></ul></li></ol><h2 id="pom"><a href="#pom" class="headerlink" title="pom"></a>pom</h2><ul><li>dependency:tree,查看pom的依赖tree</li><li>关闭依赖传递：<optional>true</optional></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>msp</title>
      <link href="/2020/01/03/xue-xi-pian/msp/"/>
      <url>/2020/01/03/xue-xi-pian/msp/</url>
      
        <content type="html"><![CDATA[<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><table><thead><tr><th align="left">软件</th><th align="left">版本</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">centos</td><td align="left">7.5</td><td align="left"></td></tr><tr><td align="left">JDK</td><td align="left">1.8</td><td align="left"></td></tr><tr><td align="left">mysql</td><td align="left">5.7+</td><td align="left"></td></tr><tr><td align="left">redis</td><td align="left">3.2+</td><td align="left"></td></tr></tbody></table><h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h3><pre class=" language-bash"><code class="language-bash">yum <span class="token function">install</span> java-1.8.0-openjdk\* -y</code></pre><h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><blockquote><p>设置mysql大小写不敏感<br>my.conf 加上 lower_case_table_names =1</p></blockquote><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">## 下载yum源</span><span class="token function">wget</span> <span class="token function">wget</span> https://dev.mysql.com/get/mysql80-community-release-el7-3.noarch.rpm<span class="token comment" spellcheck="true">## 安装yum源</span>yum -y <span class="token function">install</span> mysql80-community-release-el7-3.noarch.rpm<span class="token comment" spellcheck="true">## 查看源中激活的mysql版本</span>yum repolist all <span class="token operator">|</span> <span class="token function">grep</span> mysql<span class="token comment" spellcheck="true">## 修改源中需要安装的版本</span>yum-config-manager --disable mysql80-communityyum-config-manager --enable mysql57-community或手动编辑/etc/yum.repos.d/mysql-community.repo 文件来选择，把默认版本的enabled<span class="token operator">=</span>1改为0，需要版本的enabled<span class="token operator">=</span>1<span class="token comment" spellcheck="true">## 安装mysql</span>yum -y <span class="token function">install</span> mysql-community-server<span class="token comment" spellcheck="true">## 卸载yum源防止自动更新</span>yum -y remove mysql80-community-release-el7-3.noarch.rpm<span class="token comment" spellcheck="true">## 查看系统服务</span>systemctl list-unit-files<span class="token comment" spellcheck="true">## 设置开机启动</span>systemctl <span class="token function">enable</span> mysqld.service<span class="token comment" spellcheck="true">## 启动MySQL服务</span>systemctl start mysqld.service<span class="token comment" spellcheck="true">## 查看mysql默认密码：rcNZ-W4-2wiS</span><span class="token function">grep</span> <span class="token string">'temporary password'</span> /var/log/mysqld.log<span class="token comment" spellcheck="true">## 登录并修改默认密码</span>mysql –u root –p<span class="token comment" spellcheck="true">## 获取用户host信息进行密码修改</span>use mysql<span class="token punctuation">;</span><span class="token keyword">select</span> user,host from user<span class="token punctuation">;</span>ALTER USER <span class="token string">'user'</span>@<span class="token string">'host'</span> IDENTIFIED BY <span class="token string">'!@#123QWe'</span><span class="token punctuation">;</span>ALTER USER <span class="token string">'root'</span>@<span class="token string">'localhost'</span> IDENTIFIED BY <span class="token string">'!@#123QWe'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">## 配置中增加大小写不敏感：lower_case_table_names =1</span>vim /etc/my.cnf<span class="token comment" spellcheck="true">## 创建所有IP能访问的用户</span>create user <span class="token string">'mysql'</span>@<span class="token string">'%'</span> identified by <span class="token string">'123qweQ!'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">## 开放远程登录权限</span>GRANT ALL PRIVILEGES ON *.* TO <span class="token string">'mysql'</span>@<span class="token string">'%'</span> IDENTIFIED BY <span class="token string">'123qweQ!'</span> WITH GRANT OPTION<span class="token punctuation">;</span><span class="token comment" spellcheck="true">## 收回权限</span>REVOKE ALL PRIVILEGES ON xxl_job.* FROM msptest<span class="token punctuation">;</span>FLUSH PRIVILEGES<span class="token punctuation">;</span></code></pre><h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">## 下载redis</span><span class="token function">wget</span> http://download.redis.io/releases/redis-4.0.2.tar.gz<span class="token comment" spellcheck="true">## 解压并安装</span><span class="token function">tar</span> xzf redis-4.0.2.tar.gz -C /usr/local/<span class="token comment" spellcheck="true">## 进入redis根目录</span><span class="token function">cd</span> redis-4.0.2<span class="token comment" spellcheck="true">## 编译redis</span><span class="token function">make</span><span class="token comment" spellcheck="true">## 安装redis到系统</span><span class="token function">make</span> <span class="token function">install</span><span class="token comment" spellcheck="true">## 将初始化脚本放到/etc/init.d目录</span><span class="token function">cp</span> redis源文件夹目录/utils/redis_init_script /etc/init.d/redis_端口号<span class="token comment" spellcheck="true">## 创建目录</span><span class="token function">mkdir</span> /etc/redis <span class="token comment" spellcheck="true">## 存放Redis的配置文件</span><span class="token function">mkdir</span> -p /var/redis/端口号 <span class="token comment" spellcheck="true">## 存放Redis的持久化文件</span><span class="token comment" spellcheck="true">## 修改配置文件</span><span class="token function">cp</span> redis源文件夹目录/redis.conf /etc/redis/6379.confvim 6379.conf<span class="token comment" spellcheck="true"># daemonize yes                         使Redis以守护进程模式运</span><span class="token comment" spellcheck="true"># pidfile   /var/run/redis_端口号.pid    设置Redis的PID文件位置</span><span class="token comment" spellcheck="true"># port      端口号                       设置Redis监听的端口号</span><span class="token comment" spellcheck="true"># dir       /var/redis/端口号            设置持久化文件存放位置</span><span class="token comment" spellcheck="true">## 启动关闭服务</span>/etc/init.d/redis_6379 start/etc/init.d/redis_6379 stop<span class="token comment" spellcheck="true">## 也可以通过systemctl来配置服务为系统服务，待完善</span></code></pre><h3 id="部署脚本"><a href="#部署脚本" class="headerlink" title="部署脚本"></a>部署脚本</h3><pre class=" language-bash"><code class="language-bash"><span class="token keyword">echo</span> <span class="token string">"---------------------------eurekaserver---------------------------"</span><span class="token function">nohup</span> java -jar ~/downloads/eureka-server-1.0-SNAPSHOT.jar <span class="token operator">></span> eureka.out  2<span class="token operator">></span><span class="token operator">&amp;</span>1 <span class="token operator">&amp;</span><span class="token keyword">echo</span> <span class="token string">"---------------------------authserver---------------------------"</span><span class="token function">nohup</span> java -jar ~/downloads/auth-server-1.0-SNAPSHOT.jar <span class="token operator">></span> auth.out  2<span class="token operator">></span><span class="token operator">&amp;</span>1 <span class="token operator">&amp;</span><span class="token keyword">echo</span> <span class="token string">"---------------------------backcenterserver---------------------------"</span><span class="token function">nohup</span> java -jar ~/downloads/back-center-1.0-SNAPSHOT.jar <span class="token operator">></span> back.out  2<span class="token operator">></span><span class="token operator">&amp;</span>1 <span class="token operator">&amp;</span><span class="token keyword">echo</span> <span class="token string">"---------------------------gatewayserver---------------------------"</span><span class="token function">nohup</span> java -jar ~/downloads/gateway-zuul-1.0-SNAPSHOT.jar <span class="token operator">></span> gateway.out  2<span class="token operator">></span><span class="token operator">&amp;</span>1 <span class="token operator">&amp;</span><span class="token keyword">echo</span> <span class="token string">"---------------------------usercenterserver---------------------------"</span><span class="token function">nohup</span> java -jar ~/downloads/user-center-1.0-SNAPSHOT.jar <span class="token operator">></span> user.out  2<span class="token operator">></span><span class="token operator">&amp;</span>1 <span class="token operator">&amp;</span><span class="token function">nohup</span> java -jar ~/downloads/guns-main.jar <span class="token operator">></span> guns.out  2<span class="token operator">></span><span class="token operator">&amp;</span>1 <span class="token operator">&amp;</span></code></pre><pre class=" language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token comment" spellcheck="true">#应用信息</span>appName<span class="token operator">=</span><span class="token variable">$1</span>appExtension<span class="token operator">=</span>jarappProfile<span class="token operator">=</span><span class="token variable">$2</span>appPath<span class="token operator">=</span>/opt/msplogDate<span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">date</span> +%Y%m%d<span class="token variable">`</span></span><span class="token comment" spellcheck="true">#杀掉旧进程</span>PID<span class="token operator">=</span><span class="token punctuation">$(</span>jps -l <span class="token operator">|</span> <span class="token function">grep</span> <span class="token variable">${appName}</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{print <span class="token variable">$1</span>}'</span><span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token punctuation">[</span> -z <span class="token string">"<span class="token variable">$PID</span>"</span> <span class="token punctuation">]</span><span class="token keyword">then</span>   <span class="token keyword">echo</span> Application is already stopped<span class="token keyword">else</span><span class="token keyword">echo</span> <span class="token function">kill</span> <span class="token variable">$PID</span><span class="token function">kill</span> -9 <span class="token variable">$PID</span><span class="token keyword">fi</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token operator">!</span> -f <span class="token variable">$appPath</span>/logs/<span class="token variable">$appName</span>-<span class="token variable">$logDate</span>.log <span class="token punctuation">]</span> <span class="token keyword">then</span><span class="token function">touch</span> <span class="token variable">$appPath</span>/logs/<span class="token variable">$appName</span>-<span class="token variable">$logDate</span>.log<span class="token keyword">fi</span><span class="token comment" spellcheck="true">#起服务</span><span class="token function">nohup</span> java -jar <span class="token variable">$appPath</span>/package/<span class="token variable">$appName</span><span class="token keyword">.</span><span class="token variable">$appExtension</span> --spring.profiles.active<span class="token operator">=</span><span class="token variable">$appProfile</span> <span class="token operator">></span> <span class="token variable">$appPath</span>/logs/<span class="token variable">$appName</span>-<span class="token variable">$logDate</span>.log 2<span class="token operator">></span><span class="token operator">&amp;</span>1 <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#滚动启动日志</span><span class="token function">tail</span> -f <span class="token variable">$appPath</span>/logs/<span class="token variable">$appName</span>-<span class="token variable">$logDate</span>.log</code></pre><h3 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h3><ul><li>auth资源服务器为什么只需要被user-center和gateway依赖</li><li>SLK中间件调研</li><li>后台开发流程梳理</li><li>前端页面开发流程梳理</li><li></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> msp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux</title>
      <link href="/2020/01/02/xue-xi-pian/linux/"/>
      <url>/2020/01/02/xue-xi-pian/linux/</url>
      
        <content type="html"><![CDATA[<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><ul><li>搜索安装的包<ul><li><code>$ rpm -qa|grep redis</code></li></ul></li><li>查看包路径<ul><li><code>$ rpm -ql 包的全称</code></li></ul></li><li>启动进程<ul><li><code>$ nohup java -jar eureka-server-1.0-SNAPSHOT.jar &gt; eureka.out  2&gt;&amp;1 &amp;</code></li></ul></li><li>压缩文件<ul><li><code>$ tar czvf *.tar dir</code></li></ul></li></ul><h3 id="centos"><a href="#centos" class="headerlink" title="centos"></a>centos</h3><ul><li>uname -a<ul><li>查看系统信息</li></ul></li><li>useradd -m 用户名<ul><li>创建用户</li></ul></li><li>passwd 用户名<ul><li>设置密码</li></ul></li><li>userdel -r 用户名<ul><li>删除用户已经用户目录</li></ul></li><li>vim<ul><li>:%s/cleanup/reset/<ul><li>将cleanup替换成reset，全文替换</li></ul></li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql</title>
      <link href="/2020/01/02/xue-xi-pian/mysql/"/>
      <url>/2020/01/02/xue-xi-pian/mysql/</url>
      
        <content type="html"><![CDATA[<h2 id="centos7安装"><a href="#centos7安装" class="headerlink" title="centos7安装"></a>centos7安装</h2><ol><li>下载yum源<ul><li><code>$ wget https://dev.mysql.com/get/mysql80-community-release-el7-3.noarch.rpm</code></li></ul></li><li>安装yum源<ul><li><code>$ yum -y install mysql80-community-release-el7-3.noarch.rpm</code></li></ul></li><li>安装mysql<ul><li><code>$ yum -y install mysql-community-server</code></li></ul></li><li>卸载yum源防止自动更新<ul><li><code>$ yum -y remove mysql80-community-release-el7-3.noarch.rpm</code></li></ul></li></ol><h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><ul><li>启动服务<ul><li><code>$ systemctl start mysqld.service</code></li></ul></li><li>获取mysql初始密码<ul><li><code>$ grep "password" /var/log/mysqld.log</code></li></ul></li><li>登录mysql<ul><li><code>$ mysql -uroot -p</code></li></ul></li><li>修改初始密码<ul><li><code>$ alter user root@localhost identified by '123qweQ!';</code></li></ul></li><li>设置账号远程访问数据<ul><li>所有的地址都可以使用root用户，密码为lxh远程访问所有的数据库（远程软件登录时一定要设置下面这句）</li><li><code>$ GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'lxh' WITH GRANT OPTION;</code></li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python</title>
      <link href="/2019/12/14/xue-xi-pian/python/"/>
      <url>/2019/12/14/xue-xi-pian/python/</url>
      
        <content type="html"><![CDATA[<h2 id="python3"><a href="#python3" class="headerlink" title="python3"></a>python3</h2><ul><li>是一个解释器执行语言</li><li>解释器：通过对源码逐行解释并交由操作系统最后通过cpu执行<ul><li>逐行解释执行，可在不同操作系统安装不同解释器进行相同源代码跨平台执行</li></ul></li><li>编译器：通过对源码进行全部编译完成之后，统一交由操作系统最后让cpu执行<ul><li>需要针对不同操作系统进行源码编写编译后执行，不支持跨平台，但是运行效率高</li></ul></li></ul><h3 id="IDE-Pycharm"><a href="#IDE-Pycharm" class="headerlink" title="IDE Pycharm"></a>IDE Pycharm</h3><h3 id="IDLE"><a href="#IDLE" class="headerlink" title="IDLE"></a>IDLE</h3><ul><li>python的SHELL终端工具</li></ul><h3 id="pip3"><a href="#pip3" class="headerlink" title="pip3"></a>pip3</h3><ul><li>python包构建工具</li><li>切换国内源<ul><li>在~/.pip/pip.conf中加入源配置<pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 阿里云 ：http://mirrors.aliyun.com/pypi/simple/</span><span class="token comment" spellcheck="true"># 中国科学技术大学：https://pypi.mirrors.ustc.edu.cn/simple/</span><span class="token comment" spellcheck="true"># 清华大学：https://pypi.tuna.tsinghua.edu.cn/simple/</span><span class="token comment" spellcheck="true"># 豆瓣：http://pypi.douban.com/simple/</span><span class="token punctuation">[</span><span class="token keyword">global</span><span class="token punctuation">]</span>index<span class="token operator">-</span>url <span class="token operator">=</span> https<span class="token punctuation">:</span><span class="token operator">//</span>pypi<span class="token punctuation">.</span>tuna<span class="token punctuation">.</span>tsinghua<span class="token punctuation">.</span>edu<span class="token punctuation">.</span>cn<span class="token operator">/</span>simple<span class="token operator">/</span><span class="token punctuation">[</span>install<span class="token punctuation">]</span>trusted<span class="token operator">-</span>host<span class="token operator">=</span>pypi<span class="token punctuation">.</span>tuna<span class="token punctuation">.</span>tsinghua<span class="token punctuation">.</span>edu<span class="token punctuation">.</span>cn</code></pre></li></ul></li></ul><h3 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h3><ul><li><p>urllib</p><ul><li><p>正则表达式</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 元字符 </span><span class="token comment" spellcheck="true"># .: 任意字符</span><span class="token comment" spellcheck="true"># |: 或</span><span class="token comment" spellcheck="true"># ^: 匹配字符串开始位置</span><span class="token comment" spellcheck="true"># $: 匹配字符串结束位置</span><span class="token comment" spellcheck="true"># \: </span><span class="token comment" spellcheck="true"># *: 匹配0次到多次，等价于{0,无穷}</span><span class="token comment" spellcheck="true"># +: 匹配1次到多次，等价于{1,无穷}</span><span class="token comment" spellcheck="true"># ?: 匹配0次到1次，等价于{0,1}，也可以作为非贪婪模式的切换：'&lt;.+>': 贪婪模式, '&lt;.+?>':非贪婪模式</span><span class="token comment" spellcheck="true"># {}: 匹配次数</span><span class="token comment" spellcheck="true"># []: [^a-z],取不是a到z的字符，[a-z^]，取a到z的字符外加^</span><span class="token comment" spellcheck="true"># (): 分组</span><span class="token comment" spellcheck="true"># \b: 精确匹配单词</span><span class="token comment" spellcheck="true"># \B: 模糊匹配单词</span><span class="token comment" spellcheck="true"># \d: 匹配数字</span><span class="token comment" spellcheck="true"># \D: 不匹配数字</span><span class="token comment" spellcheck="true"># \s: 匹配空白字符，如: \t\n\r\f\v</span><span class="token comment" spellcheck="true"># \S: 不匹配空白字符</span><span class="token comment" spellcheck="true"># \w: 匹配单个单词</span><span class="token comment" spellcheck="true"># \W: 不匹配单个单词</span></code></pre></li></ul></li><li><p>scrapy爬虫框架</p><ul><li>安装<ul><li><code>$ pip3 install scrapy</code></li></ul></li><li>创建项目<ul><li><code>$ scrapy startproject</code></li></ul></li><li>执行爬虫<ul><li><code>$ scrapy crawl splidername -o xx.json -t json</code></li><li>-o:导出文件</li><li>-t:导出类型</li></ul></li></ul></li><li><p>tkinter GUI</p></li></ul><h3 id="shadowsocks"><a href="#shadowsocks" class="headerlink" title="shadowsocks"></a>shadowsocks</h3><ul><li><p>yum install python3-pip</p></li><li><p>pip3 install shadowsocks</p></li><li><p>touch /etc/shadowsocks.json</p></li><li><p>配置如下</p><pre><code>单端口：{"server":"0.0.0.0",            --服务器IP，直接用0.0.0.0也可"server_port":10001,            --端口端口"local_address": "127.0.0.1",  --本地地址，可省略"local_port":1080,             --本地端口，可省略"password":"msp20200324",         --密码"timeout":300,                 --超时时间，可省略"method":"aes-256-cfb",        --加密策略，有多重策略，具体自查}多端口：{  "server":"0.0.0.0",  "local_address":"127.0.0.1",  "local_port":1080,  "port_password":{           --每个端口对应一个密码      "1111":"password1",      "1112":"password2",      "1113":"password3"  },  "timeout":300,  "method":"aes-256-cfb",  "fast_open":false}</code></pre></li><li><p>vim /usr/local/lib/python3.6/site-packages/shadowsocks/crypto/openssl.py</p><ul><li>:%s/cleanup/reset/</li><li>:wq</li></ul></li><li><p>ssserver -c /etc/shadowsocks.json -d start/stop/restart</p></li><li><p>配置自启动</p><ul><li><p>touch /etc/systemd/system/shadowsocks.service</p></li><li><p>配置如下</p><pre><code>[Unit]Description=Shadowsocks[Service]TimeoutStartSec=0ExecStart=/usr/bin/ssserver -c /etc/shadowsocks.json[Install]WantedBy=multi-user.target</code></pre></li><li><p>systemctl enable shadowsocks</p></li><li><p>systemctl start shadowsocks</p></li><li><p>systemctl status shadowsocks -l</p></li></ul></li><li><p>firewall-cmd –zone=public –add-port=10001/tcp –permanent</p><ul><li>开放端口</li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wx</title>
      <link href="/2019/12/11/xue-xi-pian/wei-xin-gong-zhong-hao/"/>
      <url>/2019/12/11/xue-xi-pian/wei-xin-gong-zhong-hao/</url>
      
        <content type="html"><![CDATA[<h2 id="微信公众号"><a href="#微信公众号" class="headerlink" title="微信公众号"></a>微信公众号</h2><h3 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h3><ol><li>微信公众平台注册个人订阅号</li><li>如果没有云服务器和域名，想简单进行本地开发测试，可以通过免费的内网穿透软件实现，如：花生壳、Ngrok等<ul><li>内网穿透：可以让本地服务资源被外网访问</li><li><a href="http://www.ngrok.cc" target="_blank" rel="noopener">www.ngrok.cc</a></li><li><code>./sunny clientid 53f18e295de255d7 开启服务</code></li></ul></li></ol><h3 id="个人订阅号"><a href="#个人订阅号" class="headerlink" title="个人订阅号"></a>个人订阅号</h3><ul><li>未认证的个人订阅号能调用的接口有限</li><li>可以通过申请测试服务号来进行开发<ol><li>进入服务号的开发文档</li><li>选择<strong>开始开发</strong>，进行接口<strong>测试号申请</strong></li></ol></li><li>部署本地服务</li><li>在微信测试服务号上配置本地资源的外部访问url</li></ul><h3 id="企业或组织服务号"><a href="#企业或组织服务号" class="headerlink" title="企业或组织服务号"></a>企业或组织服务号</h3><h3 id="企业微信"><a href="#企业微信" class="headerlink" title="企业微信"></a>企业微信</h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> wx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uni-app</title>
      <link href="/2019/12/09/xue-xi-pian/uni-app/"/>
      <url>/2019/12/09/xue-xi-pian/uni-app/</url>
      
        <content type="html"><![CDATA[<h2 id="uni-app"><a href="#uni-app" class="headerlink" title="uni-app"></a>uni-app</h2><h3 id="微信小程序"><a href="#微信小程序" class="headerlink" title="微信小程序"></a>微信小程序</h3><ul><li>AppId:wxebbbece34f797f84</li><li>AppSecret:16c9a93f455d7831e40a8aa9d74af236</li></ul><h3 id="adb-WIFI连接手机"><a href="#adb-WIFI连接手机" class="headerlink" title="adb WIFI连接手机"></a>adb WIFI连接手机</h3><ul><li>abd连接手机2种模式<ul><li>USB<ul><li>默认监听端口5037</li><li>连接USB即可识别</li></ul></li><li>WIFI<ul><li>默认监控端口5555，默认未开启</li><li>需要先通过USB模式进行连接开启端口</li></ul><ol><li>设置WIFI监控端口为6666，并开启:<code>adb tcpip 6666</code></li><li>进行WIFI模式连接:<code>adb connect ip:port</code></li><li>手机ip可以直接通过wifi设置中详情查看</li></ol><ul><li>手机下载模拟终端(shell/Terminal),需要root<pre class=" language-bash"><code class="language-bash"><span class="token function">su</span> <span class="token operator">&amp;&amp;</span> setprop service.adb.tcp.port 5555 <span class="token operator">&amp;&amp;</span> stop adbd <span class="token operator">&amp;&amp;</span> start adbd</code></pre></li></ul></li><li>注意事项</li></ul><ol><li>更换一个网络环境需要使用新IP重新connect即可</li><li>如果手机重启了，就需要重新连接数据线再次开启端口</li><li>开启端口可以通过adb，也可以直接在手机上打开，但一般需要root权限和特殊软件</li></ol></li></ul><h3 id=""><a href="#" class="headerlink" title=""></a></h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> dcloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6</title>
      <link href="/2019/12/06/xue-xi-pian/es6/"/>
      <url>/2019/12/06/xue-xi-pian/es6/</url>
      
        <content type="html"><![CDATA[<h2 id="es6"><a href="#es6" class="headerlink" title="es6"></a>es6</h2><h3 id="ECMAScript"><a href="#ECMAScript" class="headerlink" title="ECMAScript"></a>ECMAScript</h3><ul><li>ECMA6是一个标准</li><li>js是实现</li></ul><h3 id="变量let和const"><a href="#变量let和const" class="headerlink" title="变量let和const"></a>变量let和const</h3><table><thead><tr><th align="left"></th><th align="center">重复声明</th><th align="center">变量修改</th><th align="center">块级作用域</th></tr></thead><tbody><tr><td align="left">var</td><td align="center">可以</td><td align="center">可以</td><td align="center">没有</td></tr><tr><td align="left">let</td><td align="center">不可以</td><td align="center">可以</td><td align="center">有</td></tr><tr><td align="left">const</td><td align="center">不可以</td><td align="center">不可以</td><td align="center">有</td></tr></tbody></table><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><ul><li>()=&gt; {}</li><li>只有一个入参可以省去()</li><li>只有一个return可以省去{}</li></ul><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><ul><li>收集参数<pre class=" language-javascript"><code class="language-javascript">  <span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre></li><li>展开数组<pre class=" language-javascript"><code class="language-javascript">  <span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 等同...arr</span></code></pre></li><li>默认参数<pre class=" language-javascript"><code class="language-javascript">  <span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span>c<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre></li></ul><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><ul><li>左右结构必须一致<pre class=" language-javascript"><code class="language-javascript">  <span class="token keyword">let</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>a<span class="token punctuation">,</span>b<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">[</span>c<span class="token punctuation">,</span>d<span class="token punctuation">]</span><span class="token punctuation">,</span>num<span class="token punctuation">,</span>str<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>a<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">,</span>b<span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token string">'6'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> <span class="token punctuation">[</span>json<span class="token punctuation">,</span>arr<span class="token punctuation">,</span>num<span class="token punctuation">,</span>str<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>a<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">,</span>b<span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token string">'6'</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre></li><li>声明和赋值不能分开<pre class=" language-javascript"><code class="language-javascript">  <span class="token keyword">let</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span>b<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span>b<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 会报错</span></code></pre></li></ul><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul><li>map<ul><li>映射:一个对一个</li><li>map(item)<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">]</span><span class="token keyword">let</span> result <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">return</span> item<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> result <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>item<span class="token operator">=</span><span class="token operator">></span>item<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul></li><li>reduce<ul><li>汇总:一堆出来一个</li><li>reduce(tmp,item,index)<ul><li>tmp:计算的中间值</li><li>item:数组中各个元素</li><li>index:数组索引<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">]</span><span class="token keyword">let</span> result <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>tmp<span class="token punctuation">,</span>item<span class="token punctuation">,</span>index<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">return</span> tmp<span class="token operator">+</span>item<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul></li></ul></li><li>filter<ul><li>过滤器</li><li>filter(item)<ul><li>item:数组中元素</li><li>return:false:过滤掉 true:留下<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> arr<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">{</span>title<span class="token punctuation">:</span><span class="token string">'男士包'</span><span class="token punctuation">,</span>price<span class="token punctuation">:</span><span class="token string">'50'</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span>title<span class="token punctuation">:</span><span class="token string">'女士包'</span><span class="token punctuation">,</span>price<span class="token punctuation">:</span><span class="token string">'15000'</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">let</span> result<span class="token operator">=</span>arr<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>json<span class="token operator">=</span><span class="token operator">></span>json<span class="token punctuation">.</span>price<span class="token operator">></span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul></li></ul></li><li>forEach<ul><li>循环(迭代)</li><li>forEach(item,index)<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> arr<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">{</span>title<span class="token punctuation">:</span><span class="token string">'男士包'</span><span class="token punctuation">,</span>price<span class="token punctuation">:</span><span class="token string">'50'</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span>title<span class="token punctuation">:</span><span class="token string">'女士包'</span><span class="token punctuation">,</span>price<span class="token punctuation">:</span><span class="token string">'15000'</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">let</span> result<span class="token operator">=</span>arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span>index<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token function">alert</span><span class="token punctuation">(</span>json<span class="token punctuation">.</span>price<span class="token operator">+</span><span class="token string">"-"</span><span class="token operator">+</span>index<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul></li></ul><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ul><li>startsWith<ul><li>字符串是否是***开头<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> str<span class="token operator">=</span><span class="token string">"http://www.baidu.com"</span>str<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"http"</span><span class="token punctuation">)</span></code></pre></li></ul></li><li>endsWith<ul><li>字符串是否是***结尾</li></ul></li><li>字符串模板<pre class=" language-javascript"><code class="language-javascript">  <span class="token keyword">let</span> <span class="token punctuation">[</span>title<span class="token punctuation">,</span>content<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">"demo"</span><span class="token punctuation">,</span><span class="token string">"内容"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> srt <span class="token operator">=</span> <span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>title<span class="token interpolation-punctuation punctuation">}</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>content<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">balabala`</span></span></code></pre></li></ul><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><ul><li><p>老版本的js实现</p><pre class=" language-javascript"><code class="language-javascript">  <span class="token comment" spellcheck="true">// 实现继承</span>  <span class="token comment" spellcheck="true">// 1. 拓展Object方式</span>  Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>ext<span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span>parObject<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token keyword">in</span> parObject<span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">this</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> parObject<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>speak<span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">function</span> <span class="token function">Student</span><span class="token punctuation">(</span>no<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>no <span class="token operator">=</span> no<span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>say<span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>no<span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">var</span> stu <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"001"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  stu<span class="token punctuation">.</span><span class="token function">ext</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"zhangsan"</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  stu<span class="token punctuation">.</span><span class="token function">speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 调用父类方法</span>  stu<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 调用子类方法</span>  <span class="token comment" spellcheck="true">// 2. call/apply</span>  <span class="token comment" spellcheck="true">/**      call/apply修改对象this进行js类的继承      call和apply方法一样，传参方式有差异      第一个参数：函数执行时，this指向谁      第二个参数：call更灵活，apply只支持arr数组格式  */</span>  <span class="token keyword">function</span> <span class="token function">Student</span><span class="token punctuation">(</span>no<span class="token punctuation">,</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>no <span class="token operator">=</span> no<span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>say<span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>no<span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">// 构造器对象的call调用，用来实现继承</span>      Person<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 3. 原型继承</span>  <span class="token comment" spellcheck="true">/**      js原型模式      js的类初始化会涉及3个对象，Object通过原型链的方式进行以下类似流程      var user = new User();      1、 user：实例化出来的,该对象包含一个User原型对象的引用      2、 User构造器对象：js引擎自动生成，该对象包含一个prototype属性，该属性指向的是User原型对象      3、 User原型对象：js引擎自动生成，该对象包含一个constructor属性，该属性指向的是User构造器对象  */</span>  <span class="token operator">!</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token operator">/</span>imgs<span class="token operator">/</span>原型继承<span class="token punctuation">.</span>png<span class="token punctuation">)</span>  <span class="token keyword">function</span> <span class="token function">Student</span><span class="token punctuation">(</span>no<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>no <span class="token operator">=</span> no<span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>say<span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>no<span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 会导致student的原型对象中构造函数属性变成Person</span>  Student<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"zhangsan"</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 可以通过以下方式来还原构造属性</span>  Student<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Student<span class="token punctuation">;</span>  <span class="token keyword">var</span> stu <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"001"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  stu<span class="token punctuation">.</span><span class="token function">speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 调用父类方法</span>  stu<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 调用子类方法</span></code></pre></li><li><p>es6实现</p><pre class=" language-javascript"><code class="language-javascript">  <span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>      <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token function">speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>      <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">,</span>no<span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>no <span class="token operator">=</span> no<span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>no<span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">var</span> stu <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"zhangsan"</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token string">"001"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  stu<span class="token punctuation">.</span><span class="token function">speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  stu<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul><h3 id="Json"><a href="#Json" class="headerlink" title="Json"></a>Json</h3><ul><li><p>json标准写法</p><ul><li>只能用双引号</li><li>所有的key都需要用双引号修饰</li></ul></li><li><p>常用方法</p><ul><li>JSON.stringify</li><li>JSON.parse</li></ul></li><li><p>简写</p><pre class=" language-javascript"><code class="language-javascript">  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> json <span class="token operator">=</span> <span class="token punctuation">{</span>a<span class="token punctuation">:</span>a<span class="token punctuation">,</span>b<span class="token punctuation">:</span>b<span class="token punctuation">,</span>c<span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> json <span class="token operator">=</span> <span class="token punctuation">{</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> json <span class="token operator">=</span> <span class="token punctuation">{</span>      show<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token function">simple</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span></code></pre></li></ul><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><ul><li>可以让异步代码像同步代码一样书写，增强可读性</li><li>缺点：如果异步的几个task之间有逻辑来确认继续走哪一个会特别复杂</li><li>2个常用方法<ul><li><code>Promise.all</code>: 依次执行</li><li><code>Promise.race</code>: 竞速执行，谁先申请到资源谁先执行<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>  $<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      url<span class="token punctuation">:</span> <span class="token string">"error"</span><span class="token punctuation">,</span>      dataType<span class="token punctuation">:</span> <span class="token string">"json"</span><span class="token punctuation">,</span>      <span class="token function">success</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token function">resolve</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token function">error</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token function">reject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>  $<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      url<span class="token punctuation">:</span> <span class="token string">"error"</span><span class="token punctuation">,</span>      dataType<span class="token punctuation">:</span> <span class="token string">"json"</span><span class="token punctuation">,</span>      <span class="token function">success</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token function">resolve</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token function">error</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token function">reject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 单个请求处理</span>p1<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>  <span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"success"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 多个请求处理</span>Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>p1<span class="token punctuation">,</span>p2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>  <span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>      <span class="token keyword">let</span> <span class="token punctuation">[</span>p1Result<span class="token punctuation">,</span>p2Result<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1Result<span class="token punctuation">)</span><span class="token punctuation">;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p2Result<span class="token punctuation">)</span><span class="token punctuation">;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"all success"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>      <span class="token keyword">let</span> <span class="token punctuation">[</span>p1Result<span class="token punctuation">,</span>p2Result<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1Result<span class="token punctuation">)</span><span class="token punctuation">;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p2Result<span class="token punctuation">)</span><span class="token punctuation">;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"some error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 高版本的jquery中ajax返回的默认就是promise对象，所以可以简化</span>Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>$<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>$<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>  arr<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// ...</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  err<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// ...</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul></li></ul><h3 id="generator"><a href="#generator" class="headerlink" title="generator"></a>generator</h3><ul><li>generator函数修饰符*可以用async代替</li><li>yield<ul><li>可以传参、可以返回</li><li>可以实现Promise功能，同时还可以处理多个异步的逻辑，代码依旧简洁</li><li>yield可以用await替换</li></ul></li><li>async、await<ol><li>内置执行器，generator函数需要依靠外置执行器</li><li>更好的语义</li><li>更广的适用性</li><li>返回值是Promise<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token operator">*</span><span class="token function">go</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token string">"first"</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token string">"second"</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token string">"third"</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> d <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token string">"fourth"</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token string">"ok"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">let</span> go1 <span class="token operator">=</span> <span class="token function">go</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>go1<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>go1<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>go1<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token number">33</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>go1<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token number">44</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>go1<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token number">55</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ol></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dcloud</title>
      <link href="/2019/12/03/xue-xi-pian/dcloud/"/>
      <url>/2019/12/03/xue-xi-pian/dcloud/</url>
      
        <content type="html"><![CDATA[<h2 id="uni-app"><a href="#uni-app" class="headerlink" title="uni-app"></a>uni-app</h2><ul><li><p>目录结构</p><ul><li>pages文件夹：存放app或小程序的展示页面<ul><li>.vue文件<ul><li>一个template，模板标签</li><li>一个script，js标签</li><li>多个style，样式标签</li></ul></li></ul></li><li>static文件夹<ul><li>多用于app中存放静态文件，如图片等，小程序对大小有限制，慎用</li></ul></li><li>platforms文件夹<ul><li>区分多端进行文件打包，防止非小程序的功能打包到小程序中</li></ul></li><li>app.vue：全局.vue配置</li><li>main.js：vue初始化配置</li><li>manifest.json：程序部署打包的配置中心</li><li>pages.json：全局页面配置</li><li>uni.scss：全局样式配置</li></ul></li><li><p>学习视频</p><ul><li><a href="https://www.bilibili.com/video/av76277428/?spm_id_from=333.788.videocard.2" target="_blank" rel="noopener">https://www.bilibili.com/video/av76277428/?spm_id_from=333.788.videocard.2</a></li><li><a href="https://www.bilibili.com/video/av76272693/?spm_id_from=333.788.videocard.1" target="_blank" rel="noopener">https://www.bilibili.com/video/av76272693/?spm_id_from=333.788.videocard.1</a></li><li><a href="https://www.bilibili.com/video/av76267759?from=search&amp;seid=10793715487216183160" target="_blank" rel="noopener">https://www.bilibili.com/video/av76267759?from=search&amp;seid=10793715487216183160</a></li></ul></li><li><p>css3选择器</p><ul><li>:nth-child</li><li>:nth-of-type</li><li>奇偶:odd、even</li></ul></li><li><p>flex布局</p><ul><li>justify-content：水平居中</li><li>align-items：垂直居中</li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> dcloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mac</title>
      <link href="/2019/12/02/xue-xi-pian/mac-shi-yong-ji-qiao/"/>
      <url>/2019/12/02/xue-xi-pian/mac-shi-yong-ji-qiao/</url>
      
        <content type="html"><![CDATA[<h2 id="mac"><a href="#mac" class="headerlink" title="mac"></a>mac</h2><h3 id="基本命令快捷键"><a href="#基本命令快捷键" class="headerlink" title="基本命令快捷键"></a>基本命令快捷键</h3><ul><li>commond+space<ul><li>聚焦搜索</li><li>选中的文件可以通过commond+enter进行文件路径定位</li></ul></li><li>open<ul><li>打开指定的文件夹</li></ul></li><li>vscode<ul><li>code<ul><li>可以直接通过vscode打开指定的文件</li></ul></li></ul></li><li>nohup &amp;<ul><li>nohup：不挂断运行</li><li>&amp;：后台运行</li></ul></li><li>nc<ul><li>nc localhost 9999</li><li>同telnet，进行测试远程端口是否开启</li></ul></li></ul><h3 id="brew安装"><a href="#brew安装" class="headerlink" title="brew安装"></a>brew安装</h3><ul><li><code>/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"</code><ul><li>通过curl获取链接内容，然后ruby解析执行安装</li></ul></li><li><code>brew</code><ul><li>从下载源码解压，然后./configure &amp;&amp; make install,同时会包含相关库，并自动配置各种环境变量，易于卸载</li></ul></li><li><code>brew cask</code><ul><li>已经编译好的应用包，绿色安装，易于卸载</li></ul></li></ul><h3 id="常用工具安装"><a href="#常用工具安装" class="headerlink" title="常用工具安装"></a>常用工具安装</h3><ul><li>mac下安装ADB<ul><li><code>brew cask install android-platform-tools</code></li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zookeeper</title>
      <link href="/2019/12/02/xue-xi-pian/zookeeper/"/>
      <url>/2019/12/02/xue-xi-pian/zookeeper/</url>
      
        <content type="html"><![CDATA[<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><ul><li>启动ZK服务   <ul><li><code>sh bin/zkServer.sh start</code></li></ul></li><li>查看ZK服务状态<ul><li><code>sh bin/zkServer.sh status</code></li></ul></li><li>停止ZK服务<ul><li><code>sh bin/zkServer.sh stop</code></li></ul></li><li>重启ZK服务<ul><li><code>sh bin/zkServer.sh restart</code></li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kafka</title>
      <link href="/2019/12/02/xue-xi-pian/kafka/"/>
      <url>/2019/12/02/xue-xi-pian/kafka/</url>
      
        <content type="html"><![CDATA[<h2 id="kafka概述"><a href="#kafka概述" class="headerlink" title="kafka概述"></a>kafka概述</h2><ul><li>消息队列内部实现原理<ul><li>发布订阅模式（一对多，数据生产后，推送给所有订阅者）<ul><li>推送带宽由kafka决定，可能会与不同客户端带宽差异化</li></ul></li><li>点对点模式（一对一，消费者主动拉取数据）<ul><li>客户端决定带宽，但是需要监听kafka是否有数据</li></ul></li></ul></li><li>基于scala开发，需要zookeeper支持</li><li>kafka架构图<ul><li><img src="/imgs/kafka%E6%9E%B6%E6%9E%84.png" alt=""></li></ul></li></ul><h2 id="kafka集群部署"><a href="#kafka集群部署" class="headerlink" title="kafka集群部署"></a>kafka集群部署</h2><ul><li>启动kafka<ul><li><code>/usr/local/Cellar/kafka/2.2.1/bin/kafka-server-start /usr/local/etc/kafka/server.properties</code></li></ul></li><li>创建topic<ul><li><code>/usr/local/Cellar/kafka/2.2.1/bin/kafka-topics --zookeeper localhost:2181 --create --topic yw_topic --partitions 30  --replication-factor 2</code><ul><li>–zookeeper：绑定的zookeeper连接信息</li><li>–topic：kafka的主题</li><li>–partitions：分区数量</li><li>–replication：副本数量，不能大于kafka实例数（broker数量）</li></ul></li></ul></li><li>查看topic<ul><li><code>kafka-topics --zookeeper localhost:2181 --list</code></li></ul></li><li>创建生产者<ul><li><code>kafka-console-producer --broker-list localhost:9092 --topic yw_topic</code></li></ul></li><li>创建消费者<ul><li><code>kafka-console-consumer --bootstrap-server localhost:9092 --topic yw_topic --from-beginning</code><ul><li>–from-beginning：从最开始消费信息</li><li>–bootstrap-server：老版本是依赖zookeeper，新版本直接读本机的kafka服务进行消费</li></ul></li></ul></li><li>topic详情<ul><li><code>kafka-topics --zookeeper localhost:2181 --describe topic yw_topic</code><ul><li>查看topic详情，其中有个isr参数代表的是topic leader选举机制排序</li><li>选举策略：和当前leader数据最接近的broker节点作为新的leader服务<h2 id="kafka工作流程"><a href="#kafka工作流程" class="headerlink" title="kafka工作流程"></a>kafka工作流程</h2></li></ul></li></ul></li><li>角色<ul><li>Topics：topic可以理解为一类消息</li><li>Partition：每个Topic将分成多个partition，partition可以有效提升并发消费的能力</li><li>Logs：partition在存储层面的append log文件，文件以追加的形式增长</li><li>Offset：偏移量，消息在log中的标识</li><li>Consumers：消费者，每个Consumer属于一个Consumer Group，发送到Topic的消息，只会被订阅了此Topic的每个Group中的一个Consumer消费<ul><li>如果所有的Consumer都具有相同的的Group，这种情况和queue模式很像；消息会在Consumers之间负载均衡</li><li>如果所有的Consumer都具有不同的的Group，那就是发布-订阅模式；消息会广播给所有Consumers</li><li>对于一个Topic，同一个Group中不能有多于Partition个数的Consumer同时消费</li></ul></li><li>Producers：生产者，将消息发布到指定的Topic，Producer能决定消息属于Topic中的那个Partition</li></ul></li><li>写入方式<ul><li>producer采用推(push)的方式将消息发布到broker，消息都是追加方式进行写入，属于顺序写磁盘，比随机写内存效率高</li><li>ack机制<ul><li>0：生产者只管发送消息，不需要接收方确认</li><li>1：生产者发送消息，需要接收方确认</li><li>all：生产者发送消息，需要接收方确认，同时需要保证接收方的副本都同步完成</li></ul></li></ul></li><li>分区原则<ul><li>指定了patition直接使用</li><li>未指定patition但指定了key，通过对key进行hash出一个patition</li><li>如果key也没指定，就轮询</li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis</title>
      <link href="/2019/11/29/xue-xi-pian/redis/"/>
      <url>/2019/11/29/xue-xi-pian/redis/</url>
      
        <content type="html"><![CDATA[<h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><ul><li>Remote Dictionary Server(远程数据服务)</li><li>Nosql数据库，遵守BSD协议（支持二次封装商用或开源）</li><li>优点<ul><li>丰富的数据存储结构</li><li>高速读写，</li></ul></li><li>缺点<ul><li>内存消耗高</li><li>持久化</li></ul></li><li>redis.conf配置中心</li><li>需要注意redis的内存管理策略</li><li>单线程误区<ul><li>某些环节是单线程，不代表redis的整个处理流程采用的单线程</li><li>可以通过多实例部署来进行多进程处理</li><li>io多路复用</li><li>纯内存操作，瓶颈不在cpu</li><li>减少锁的控制，减少线程切换</li></ul></li></ul><h3 id="redis-by-java"><a href="#redis-by-java" class="headerlink" title="redis by java"></a>redis by java</h3><ul><li>jedis<ul><li>通过类redis-cli命令的方式进行redis操作</li><li>支持多种方式序列化<ul><li><strong>默认</strong>jdk自带的序列化</li><li>可定制为fastjson格式的序列化，占用空间更小，切容易被反序列化</li></ul></li></ul></li><li>redistemplate<ul><li>相比jedis封装的更抽象</li><li>支持多种方式序列化<ul><li>StringRedisTemplate方式为自带jdk序列化</li><li>RedisTemplate方式支持多种<ul><li>默认：Jackson2JsonRedisSerializer</li><li>目前较流行：FastJson2JsonRedisSerializer</li></ul></li></ul></li></ul></li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li>redis是有C语言编写，需要先安装GCC依赖，一般默认都有</li><li>下载<ul><li><code>$ wget -P ~/soft http://download.redis.io/releases/redis-5.0.7.tar.gz</code></li></ul></li><li>解压<ul><li><code>$ tar -zxvf ***.tar.gz</code></li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一建建筑</title>
      <link href="/2019/11/26/xue-xi-pian/yi-jian-jian-zhu/"/>
      <url>/2019/11/26/xue-xi-pian/yi-jian-jian-zhu/</url>
      
        <content type="html"><![CDATA[<h2 id="2年周期过以下科目"><a href="#2年周期过以下科目" class="headerlink" title="2年周期过以下科目"></a>2年周期过以下科目</h2><p><img src="/imgs/%E4%B8%80%E5%BB%BA%E8%80%83%E9%A2%98%E5%88%86%E6%9E%90%E8%A1%A8.png" alt=""></p><h2 id="经济-100分"><a href="#经济-100分" class="headerlink" title="经济 100分 ****"></a>经济 100分 ****</h2><ol><li>60及格<h2 id="法规-130分"><a href="#法规-130分" class="headerlink" title="法规 130分 ***"></a>法规 130分 ***</h2></li><li>78及格<h2 id="项目管理-130分"><a href="#项目管理-130分" class="headerlink" title="项目管理 130分 ***"></a>项目管理 130分 ***</h2></li><li>78及格</li><li>知识点</li></ol><ul><li>建设工程项目管理：业主方项目管理（核心），施工方项目管理等</li><li>建设工程管理：决策期、实施期、使用期，是对建设工程的专业性管理，同时是一种增值服务</li><li>施工方项目管理在服务业主或建筑方之上，再考虑自身利益</li><li>业主方式整个项目的核心，关心的是整个项目的总投资额，各个参建方都是为其服务的</li><li>业主方在项目管理过程中最重要的任务是安全问题<h2 id="实物-160分"><a href="#实物-160分" class="headerlink" title="实物 160分 *****"></a>实物 160分 *****</h2></li></ul><ol><li>96及格</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 考证 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式理论</title>
      <link href="/2019/11/22/xue-xi-pian/fen-bu-shi-li-lun/"/>
      <url>/2019/11/22/xue-xi-pian/fen-bu-shi-li-lun/</url>
      
        <content type="html"><![CDATA[<h2 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h2><ul><li>C:Consistent，一致性</li><li>A:Available，可用性</li><li>P:Partition tolerance，分区容错性<br>理解CAP理论的最简单方式是想象两个节点分处分区两侧。允许至少一个节点更新状态会导致数据不一致，即丧失了C性质。如果为了保证数据一致性，将分区一侧的节点设置为不可用，那么又丧失了A性质。除非两个节点可以互相通信，才能既保证C又保证A，这又会导致丧失P性质。</li><li><a href="https://mwhittaker.github.io/blog/an_illustrated_proof_of_the_cap_theorem/" target="_blank" rel="noopener">https://mwhittaker.github.io/blog/an_illustrated_proof_of_the_cap_theorem/</a></li></ul><h2 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h2><ul><li>BA:Basically Available，基本可用</li><li>S:Soft State，软状态，属于非0非1的中间态</li><li>E:Eventually Consistent，最终一致性</li><li>是对AP模式的一种拓展</li></ul><h2 id="本地事务"><a href="#本地事务" class="headerlink" title="本地事务"></a>本地事务</h2><ul><li>A(Atomic)：原子性，构成事务的所有操作要么全部成功，要么全部失败，关注的是状态</li><li>C(Consistency)：一致性，关注的是数据的可见性，和多线程中的可见性一致，中间状态的数据对外部不可见，只有最初状态和最终状态的数据对外可见</li><li>I(Isolation)：隔离性，各个事务是并发执行的，之间需要具备一定隔离性</li><li>D(Durability)：持久性，事务操作成功后，需要将数据的改变持久化</li></ul><h2 id="分布式事务解决方案"><a href="#分布式事务解决方案" class="headerlink" title="分布式事务解决方案"></a>分布式事务解决方案</h2><ol><li>2PC</li></ol><ul><li>2阶段提交，Prepare phase，Commit phase</li><li>Prepare phase：在准备阶段，各个数据库参与者作为本地事务会记录Undo/Redo日志</li></ul><h3 id="XA方案"><a href="#XA方案" class="headerlink" title="XA方案"></a>XA方案</h3><ul><li>国际开放标准组织Open Group定义了DTP(Distributed Transaction Processing Reference Model)分布式事务标准模型</li><li>DTP包含的角色：<ul><li>AP：应用程序</li><li>RM：资源服务器（各个数据库服务器）</li><li>TM：事务管理器</li><li>DTP定义了TM和RM之间通讯接口规范是XA</li></ul></li><li>角色交互方式<ul><li>TM向AP提供应用程序编程接口，AP通过TM提交或回滚事务</li><li>TM通过XA接口通知RM数据库事务的开始、结束以及提交、回滚等</li></ul></li><li>缺点<ul><li>需要本地数据库支持XA协议</li><li>准备阶段的资源锁定需要等到2个阶段全部执行完才能释放，性能较差</li></ul></li></ul><h3 id="Seata方案"><a href="#Seata方案" class="headerlink" title="Seata方案"></a>Seata方案</h3><ul><li>在应用层进行全局事务控制，不会长时间占用连接资源</li><li>目前支持2PC和TCC2种模式</li><li>角色<ul><li>TC(transaction coordinator):事务协调者</li><li>TM(transaction manager):事务管理者</li><li>RM(resource manager):资源服务器</li></ul></li><li>角色交互<br><img src="/imgs/seata%E6%B5%81%E7%A8%8B.png" alt=""></li></ul><ol start="2"><li>TCC</li></ol><ul><li>Try、Commit、Cancel</li><li>空回滚<ul><li>T没执行Cancel先执行了</li></ul></li><li>幂等<ul><li>多次执行commit</li></ul></li><li>悬挂<ul><li>Cancle在T先执行</li></ul></li><li>事务控制交给业务逻辑的代码层，可以更加灵活处理分布式事务相关异常问题</li><li>减少对数据库连接资源或数据锁定的时间，增大了系统的吞吐量</li></ul><h2 id="可靠消息最终一致性方案"><a href="#可靠消息最终一致性方案" class="headerlink" title="可靠消息最终一致性方案"></a>可靠消息最终一致性方案</h2><ol><li>本地消息表方案</li></ol><ul><li>在本地数据库中增加一个消息表，每次操作完一个业务就同步增加一个消息</li><li>通过定时任务往消息中间件中同步本地消息表的记录</li><li>中间件推送消息给消费方，通过ack机制进行消息确认，以确保消息被成功消费</li></ul><ol start="2"><li>事务消息机制</li></ol><ul><li>张三给李四转钱</li><li>MQ发起方发送消息给MQServer（李四加钱）</li><li>MQServer接受消息并标记为不可消费，然后回复发起方成功接到消息</li><li>MQ发起方执行张三扣款的本地事务，如果成功则通知MQServer可以消费消息，失败则删除消息</li><li>成功之后MQ消费方可以正常消费消息</li></ul><h2 id="最大努力通知"><a href="#最大努力通知" class="headerlink" title="最大努力通知"></a>最大努力通知</h2><ol><li>与可靠消息方案区别</li></ol><ul><li>可靠消息是由发起方保证一致性，最大努力是由接收方保证</li><li>可靠消息主要处理的是交易过程的场景，最大努力处理的是交易后的一种通知场景</li><li>最大努力需要提供回查接口给接受方进行消息的查询</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th align="left"></th><th align="center">2PC</th><th align="center">TCC</th><th align="center">可靠消息</th><th align="center">最大努力通知</th></tr></thead><tbody><tr><td align="left">一致性</td><td align="center">强一致性</td><td align="center">最终一致性</td><td align="center">最终一致性</td><td align="center">最终一致性</td></tr><tr><td align="left">吞吐量</td><td align="center">低</td><td align="center">中</td><td align="center">高</td><td align="center">高</td></tr><tr><td align="left">实现复杂度</td><td align="center">易</td><td align="center">难</td><td align="center">中</td><td align="center">易</td></tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2019/11/21/xue-xi-pian/she-ji-mo-shi/"/>
      <url>/2019/11/21/xue-xi-pian/she-ji-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="java特性"><a href="#java特性" class="headerlink" title="java特性"></a>java特性</h2><ol><li>封装</li><li>抽象</li><li>继承</li><li>多态</li></ol><h2 id="设计模式原则"><a href="#设计模式原则" class="headerlink" title="设计模式原则"></a>设计模式原则</h2><ol><li>单一职责</li></ol><ul><li>一个对象的改变只由一个原因导致</li><li>不同逻辑的接口分割成单一逻辑接口</li><li>大到接口、中到实现类、小到方法尽量遵守</li></ul><ol start="2"><li>里氏替换</li></ol><ul><li>子类可以拓展父类的功能，但是不能变更</li><li>子类相比父类方法需要多（入参类型更广）入（方法入参）少（出参类型更窄）出（方法出参）的 </li></ul><ol start="3"><li>依赖倒置</li></ol><ul><li>高层组件：调用端（客户端）</li><li>底层组件：具体实现类</li><li>不能让高层组件依赖低层组件，两者都应依赖于抽象</li></ul><ol start="4"><li>接口隔离</li></ol><ul><li>依赖于单一职责原则，接口原子化</li><li>单一逻辑接口由于权限不同需要继续细化</li></ul><ol start="5"><li>迪米特</li></ol><ul><li>最小知识原则，尽量减少使用public接口</li><li>只与朋友交流</li></ul><ol start="6"><li>开闭</li></ol><ul><li>对修改关闭，对拓展开放</li></ul><h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><h3 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h3><h3 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h3><h3 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h3><h3 id="单例模式-Singleton"><a href="#单例模式-Singleton" class="headerlink" title="单例模式-Singleton"></a>单例模式-Singleton</h3><ol><li>饿汉式，静态成员变量实例化，构造方法私有化，jvm保证只有一个实例</li><li>懒汉式，判断实例是否为null，如果是则new，存在多线程并发访问问题</li><li>懒汉式+方法级别锁，解决2的问题，效率变慢</li><li>懒汉式+代码块锁，双重null校验，解决2的问题，效率较3快一点</li><li>静态内部类进行单例对象实例化，通过对外接口进行实例返回，达到懒汉效果，同时jvm保证只有一个实例</li><li>枚举实现单例，防止反序列化</li></ol><h3 id="策略模式-Strategy"><a href="#策略模式-Strategy" class="headerlink" title="策略模式-Strategy"></a>策略模式-Strategy</h3><ol><li>定义了算法框架，让他们分开独立实现</li><li>多用组合，少用继承思想</li><li>除了继承之外更加灵活的实现方式</li><li>针对超类/接口编程</li><li>利用java多态特性<br>demo：鸭子对象具备的不同行为，不同鸭子在相同行为下不同的表现，这些都可以用到策略模式，鸭子作为类别，行为可以看做算法，算法可以独立变化形成框架，类别基本不会变化太大，具备对象基本特征。</li></ol><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><ol><li>简单工厂</li></ol><ul><li>是实现创建对象的一种封装，不属于设计模式，属于一种实现技巧或方法</li><li>客户端与工厂关系1:1</li></ul><ol start="2"><li>工厂方法-Factory Method</li></ol><ul><li>使用继承，通过父类工厂的创建对象方法，在父类中增加创建的抽象方法来实现</li><li>将对象的创建委托给子类工厂，子类工厂实现超类工厂方法来创建对象</li><li>用于创建单个产品</li><li>客户端与工厂的关系变成n:1</li></ul><ol start="3"><li>抽象工厂-Abstract Factory</li></ol><ul><li>使用对象组合</li><li>对象的创建被实现在工厂接口暴露出来的方法中</li><li>提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类</li><li>抽象工厂中包含工厂方法的实现</li><li>简单理解为对工厂方法的再次封装，创建组合产品</li></ul><ol start="4"><li>利用java依赖倒置原则</li></ol><h3 id="门面模式-Facade"><a href="#门面模式-Facade" class="headerlink" title="门面模式-Facade"></a>门面模式-Facade</h3><ol><li>简化接口</li><li>给子系统增加外观，简化对子系统的直接操作</li><li>MVC中的V就属于门面模式</li></ol><h3 id="调停者模式-Mediator"><a href="#调停者模式-Mediator" class="headerlink" title="调停者模式-Mediator"></a>调停者模式-Mediator</h3><ol><li>语法同门面模式</li><li>语义上是简化内部接口之间的调用或操作，通过调停者对象进行间接访问</li></ol><h3 id="责任链模式-Chain-of-Responsibility"><a href="#责任链模式-Chain-of-Responsibility" class="headerlink" title="责任链模式-Chain of Responsibility"></a>责任链模式-Chain of Responsibility</h3><ol><li>sevlet中的Filter链就是运用的该模式</li></ol><ul><li>原理：request经过Filter1-&gt;Filter2-&gt;Filter3-&gt;reponse-&gt;Filter3-&gt;Filter2-&gt;Filter1</li><li>doFilter方法入参有(req,resp,filterChain)，出参是Boolean来控制是否需要走下一个链</li></ul><ol start="2"><li>基于策略模式，不同之处在于将策略模式中变化的部分进行整合到List管理</li></ol><h3 id="装饰者模式-Decorator"><a href="#装饰者模式-Decorator" class="headerlink" title="装饰者模式-Decorator"></a>装饰者模式-Decorator</h3><ol><li>动态将功能附加到对象上，比继承更具有弹性的替换方案</li><li>装饰者和组件（被装饰者）基于同一个抽象，保证他们具有相同的类型</li><li>组件+装饰者=带有装饰者功能的组件</li><li>装饰另一个对象，并提供相应的行为</li></ol><h3 id="观察者模式-Observer"><a href="#观察者模式-Observer" class="headerlink" title="观察者模式-Observer"></a>观察者模式-Observer</h3><ol><li>事件驱动也使用该模式</li></ol><ul><li>事件源，事件本身（会持有事件源依赖），事件消费者（hook、listener、callback、observer）</li></ul><ol start="2"><li>定义了对象1:n的关系</li><li>被观察者（主题）由于某种状态的变化会主动通知信息给所有观察者</li></ol><ul><li>内容的传递有PULL拉和PUSH推2种，一般采用推</li><li>java有自带的该模式实现，但是Observable是一个类，拓展性较差</li></ul><ol start="4"><li>语法同责任链模式</li></ol><h3 id="组合模式-Composite"><a href="#组合模式-Composite" class="headerlink" title="组合模式-Composite"></a>组合模式-Composite</h3><ol><li>允许你将对象组合成树形结构来表现“整体/部分”层次结构，组合能让客户以一致的方式处理个别对象以及对象组合</li><li>牺牲一点单一职责原则换来组合节点和叶子节点的操作透明，对于客户而言，操作叶子节点和操作组合节点是一样的，但是有安全性问题：叶子节点执行添加元素操作，需要额外的增加instanceof来进行操作节点属性判断（叶子节点或组合节点）</li><li>透明性和安全性这种考虑</li></ol><ul><li>透明性：同等对待叶子节点和组合节点</li><li>安全性：避免叶子节点调用组合节点的功能出现问题</li></ul><h3 id="享元模式-Flyweight"><a href="#享元模式-Flyweight" class="headerlink" title="享元模式-Flyweight"></a>享元模式-Flyweight</h3><ol><li>各种池的设计都是利用该模式</li><li>可以结合组合模式</li><li>java中String就是利用该模式（常量池）</li></ol><h3 id="代理模式-Proxy"><a href="#代理模式-Proxy" class="headerlink" title="代理模式-Proxy"></a>代理模式-Proxy</h3><ol><li>包装另一个对象，并控制对它的访问</li><li>为另一个对象提供一个替身或者占位符以控制对这个对象的访问</li><li>被代理对象可以是远程对象、创建开销大的对象、需要安全控制的对象</li></ol><ul><li>远程代理：创建一个远程服务的代表，对这个代表的访问就相当于对远程服务的访问，代表实现了和远程服务的链接交互等问题</li><li>虚拟代理：对于创建开销特别大的真实对象，虚拟代表会在真实对象创建过程中协助处理，等创建完成后将请求转发到真实对象</li><li>保护代理（动态代理）：基于接口的动态代理，在运行时，可根据需要动态生成代理类，System.getProperties().put(“jdk.proxy.ProxyGenerator.SaveGenerateFiles”,”true”)</li><li>java自带的动态代理基于接口，cglib三方包支持类，都是基于ASM底层实现</li><li>Spring AOP</li></ul><h3 id="迭代器模式-Iterator"><a href="#迭代器模式-Iterator" class="headerlink" title="迭代器模式-Iterator"></a>迭代器模式-Iterator</h3><ol><li>容器的遍历迭代</li><li>数据存储物理结构</li></ol><ul><li>数组</li><li>链表</li></ul><ol start="3"><li>图标，栈，二叉树，队列等等都是逻辑结构，底层实现都是上述2种物理结构</li><li>将不同逻辑结构的数据容器封装一个相同的抽象方法iterator，各自去实现该方法</li></ol><h3 id="访问者模式-Visitor"><a href="#访问者模式-Visitor" class="headerlink" title="访问者模式-Visitor"></a>访问者模式-Visitor</h3><ol><li>在不改变对象内部结构的情况下，动态改变内部元素的动作</li><li>编译器原理用到该模式</li><li>asm将类字节码（结构稳定），通过该模式可以增加不同的访问对象来动态改变内部元素的动作</li></ol><h3 id="建造者模式-Builder"><a href="#建造者模式-Builder" class="headerlink" title="建造者模式-Builder"></a>建造者模式-Builder</h3><ol><li>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</li><li>model多参数构建，可以通过set器指定初始化部分元素，也可以用该模式抽象封装出一个建造者实现来完成</li></ol><h3 id="适配器模式-Adapter"><a href="#适配器模式-Adapter" class="headerlink" title="适配器模式-Adapter"></a>适配器模式-Adapter</h3><ol><li>接口功能转换</li><li>转接头</li><li>对象适配：通过对象组合实现</li><li>类适配：通过类继承实现</li></ol><h3 id="桥接模式-Bridge"><a href="#桥接模式-Bridge" class="headerlink" title="桥接模式-Bridge"></a>桥接模式-Bridge</h3><ol><li>双维度拓展，具体和抽象支持同时拓展</li><li>抽象维度中持有具体对象的引用</li><li>装饰模式的升级，支持装饰模式中被装饰者的自我拓展</li></ol><h3 id="命令模式-Command"><a href="#命令模式-Command" class="headerlink" title="命令模式-Command"></a>命令模式-Command</h3><ol><li>调用者依赖命令对象，命令执行依赖接受者，最终接受者执行操作</li><li>应用场景：日程安排（Scheduler）、线程池、工作队列</li><li>通过对命令的有序执行，可以进行有序回退</li><li>将动作对象化，可以进行更好的存储、传递和调用</li><li>可以通过多个命令组合生成宏命令进行使用</li><li>聪明命令对象：直接实现了请求，而没有将请求委托给接收者</li></ol><h3 id="原型模式-Prototype"><a href="#原型模式-Prototype" class="headerlink" title="原型模式-Prototype"></a>原型模式-Prototype</h3><ol><li>用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象</li></ol><h3 id="模板方法模式-Template-Method"><a href="#模板方法模式-Template-Method" class="headerlink" title="模板方法模式-Template Method"></a>模板方法模式-Template Method</h3><ol><li>对一类算法进行封装，将算法和各个算法实现的解耦</li><li>对一类算法进行封装，将模板方法中算法的实现可以延时到子类完成，同时子类可以在不改变算法框架的前提，改变算法内容算法和各个算法实现的解耦</li><li>模板：即方法，此方法定义了一套算法的步骤，一般为了防止算法框架被变更，可以通过final定义，不让子类继承修改</li><li>钩子的应用：可以在模板方法中加入钩子方法的调用，默认给钩子方法一个空的实现，让子类可以选择性的去实现，或者通过钩子方法返回标识来控制模板方法中哪些算法步骤需要加入算法框架</li><li>场景：数组的sort排序，比较的算法是通过排序对应的对象继承Comparable接口实现的，模板方法提供算法框架；io流的read同理</li><li>好莱坞原则：不要给我打电话，我会打电话给你，高层决定如何以及何时调用底层组件</li><li>工厂方法是模板方法的一个特殊场景</li></ol><h3 id="备忘录模式-Memento"><a href="#备忘录模式-Memento" class="headerlink" title="备忘录模式-Memento"></a>备忘录模式-Memento</h3><ol><li>记录对象的状态</li><li>存盘功能，需要将对象以及对象的引用全部序列化Serializabe，或者通过transient将对象中的引用透明化（不序列化标志）</li></ol><h3 id="状态模式-State"><a href="#状态模式-State" class="headerlink" title="状态模式-State"></a>状态模式-State</h3><ol><li>与策略模式属于“双胞胎”</li><li>允许对象在内部状态改变的时候改变他的行为，对象看起来好像修改了它的类</li><li>任何通过状态获取对应行为在设计之初都是定义好了的，不需要调用者进行状态行为的决策<br><img src="/imgs/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%9B%BE.png" alt=""></li></ol><h3 id="解释器模式-Interpreter"><a href="#解释器模式-Interpreter" class="headerlink" title="解释器模式-Interpreter"></a>解释器模式-Interpreter</h3><ol><li>给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>io模型</title>
      <link href="/2019/11/20/xue-xi-pian/io-mo-xing/"/>
      <url>/2019/11/20/xue-xi-pian/io-mo-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="同步-异步-阻塞-非阻塞"><a href="#同步-异步-阻塞-非阻塞" class="headerlink" title="同步 异步 阻塞 非阻塞"></a>同步 异步 阻塞 非阻塞</h2><ul><li>同步异步是消息通讯机制</li><li>阻塞非阻塞关注的是等待消息的状态<br>demo：<br>张三完成烧水：张三发起烧水动作，水壶放在炉子上</li><li>同步：水烧好后继续由张三操作</li><li>阻塞：张三发起烧水动作到水烧好的这个等待状态是不做任何事</li><li>异步：张三事先设置水烧好就出发机关自动关闭炉子获取其他事项，不再由张三继续操作</li><li>非阻塞：张三发起烧水动作到水烧好的这个等待状态去看了电视</li></ul><h2 id="五大io模型"><a href="#五大io模型" class="headerlink" title="五大io模型"></a>五大io模型</h2><h3 id="IO数据准备和数据从内核拷贝到应用进程是2个独立的过程"><a href="#IO数据准备和数据从内核拷贝到应用进程是2个独立的过程" class="headerlink" title="IO数据准备和数据从内核拷贝到应用进程是2个独立的过程"></a>IO数据准备和数据从内核拷贝到应用进程是2个独立的过程</h3><h3 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h3><p><img src="/imgs/%E9%98%BB%E5%A1%9Eio.jpeg" alt=""></p><h3 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h3><p><img src="/imgs/%E9%9D%9E%E9%98%BB%E5%A1%9Eio.jpeg" alt=""></p><h3 id="复用IO"><a href="#复用IO" class="headerlink" title="复用IO"></a>复用IO</h3><p><img src="/imgs/%E5%A4%8D%E7%94%A8io.jpeg" alt=""></p><h3 id="信号驱动IO"><a href="#信号驱动IO" class="headerlink" title="信号驱动IO"></a>信号驱动IO</h3><p><img src="/imgs/%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8io.jpeg" alt=""></p><h3 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h3><p><img src="/imgs/%E5%BC%82%E6%AD%A5io.jpeg" alt=""></p><h3 id="模型对比"><a href="#模型对比" class="headerlink" title="模型对比"></a>模型对比</h3><p><img src="/imgs/io%E6%A8%A1%E5%9E%8B%E5%AF%B9%E6%AF%94.png" alt=""></p><h2 id="BIO-NIO-AIO-Netty"><a href="#BIO-NIO-AIO-Netty" class="headerlink" title="BIO NIO AIO Netty"></a>BIO NIO AIO Netty</h2><h3 id="BIO-Blocking-IO"><a href="#BIO-Blocking-IO" class="headerlink" title="BIO(Blocking IO)"></a>BIO(Blocking IO)</h3><ul><li>服务等待连接阻塞</li><li>服务与客户端信息read，write阻塞</li><li>一个连接就需要开一个线程处理连接服务之后的与客户端信息read，write任务</li><li>数据read是一个字节一个字节进行</li></ul><h3 id="NIO（New-IO）"><a href="#NIO（New-IO）" class="headerlink" title="NIO（New IO）"></a>NIO（New IO）</h3><ol><li>单线程模型（Single Thread）<ul><li>主线程有一个selector（选择器）</li><li>selector负责轮询查看是否有新客户端要连接到服务，同时查看客户-服务建立的通道是否数据传输已经准备好</li><li>selector会在服务端接受的所有请求放置key（一个请求对应一个key，监听）进行轮询，如果轮询发现有多个key（多个请求），则进行遍历处理</li><li>接着就是对这些key对应的连接请求放置另一个状态的监听（read，write），再次轮询，如果有则进行read，write，原理同上</li><li>selector监听了连接以及数据读写全部的任务</li><li>数据read是和buffer（api极其难用，flip复位问题难以排查）绑定，批量进行</li></ul></li><li>多线程模型（reactor），响应编程<ul><li>selector只负责轮询是否有连接，同时管理一个worker(线程池)去处理read，write</li><li>当服务端接受的信息worker忙不过来了，可以考虑kafka消息队列存储，然后依次处理</li><li>channel：通道，是一个信息交互的媒介，逻辑概念；队列：是一个存储信息的概念</li></ul></li><li>主从线程模型</li></ol><h3 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h3><ul><li>不需要轮询</li><li>由系统监听是否有连接，然后主动告知selector去管理</li><li>windows有对AIO的底层实现，linux中AIO和NIO的底层实现都是通过epoll，AIO多封装了一层</li></ul><h3 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h3><ul><li>服务端<br><img src="/imgs/nettyserver.png" alt=""></li><li>客户端<br><img src="/imgs/nettyclient.png" alt=""></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> io </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm调优</title>
      <link href="/2019/11/20/xue-xi-pian/jvm-diao-you/"/>
      <url>/2019/11/20/xue-xi-pian/jvm-diao-you/</url>
      
        <content type="html"><![CDATA[<h2 id="jdk、jre和jvm"><a href="#jdk、jre和jvm" class="headerlink" title="jdk、jre和jvm"></a>jdk、jre和jvm</h2><p><img src="/imgs/jdk.png" alt=""></p><h2 id="jvm"><a href="#jvm" class="headerlink" title="jvm"></a>jvm</h2><ul><li><p>classic VM：第一款商用</p></li><li><p>hotspot VM：热门VM</p><ul><li><p><img src="/imgs/hotspotcomponent.png" alt=""></p></li><li><p>将引用分为4种</p><ol><li>Strong：通过new出来的对象</li><li>Soft：继承SoftReference<ul><li>内存不足时一定会被GC，长期不用也会被GC</li></ul></li><li>Weak：继承WeakReference<ul><li>一定会被GC，当被mark为dead，会在ReferenceQueue中通知</li></ul></li><li>Phantom：继承PhantomReference<ul><li>本来就没引用，当从jvm heap释放会通知</li></ul></li></ol></li><li><table><thead><tr><th>引用类型</th><th>被垃圾回收时间</th><th>用途</th><th>生存时间</th></tr></thead><tbody><tr><td>强引用</td><td>从来不会</td><td>对象的一般状态</td><td>JVM停止运行时终止</td></tr><tr><td>软引用</td><td>当内存不足时</td><td>对象缓存</td><td>内存不足时终止</td></tr><tr><td>弱引用</td><td>正常垃圾回收时</td><td>对象缓存</td><td>垃圾回收后终止</td></tr><tr><td>虚引用</td><td>正常垃圾回收时</td><td>跟踪对象的垃圾回收</td><td>垃圾回收后终止</td></tr></tbody></table></li></ul></li><li><p>JVM参数选项</p><ul><li>-XX:+&lt; option &gt;<ul><li>代表开启option选项</li></ul></li><li>-XX:-&lt; option &gt;<ul><li>代表关闭option选项</li></ul></li><li>-XX:&lt; option &gt;=&lt; value &gt;<ul><li>代表将option选项值设置为value</li></ul></li><li><code>java -XX:+PrintCommandLineFlags -version</code><ul><li>打印当前机器jvm的默认参数信息</li></ul></li></ul></li><li><p>jvm中gc相关选项</p><ul><li>-verbose:gc<ul><li>冗余gc信息输出</li></ul></li><li>-Xms20m<ul><li>heap最小空间大小</li></ul></li><li>-Xmx20m<ul><li>heap最大空间大小</li></ul></li><li>-Xmn10m<ul><li>heap中新生代大小</li></ul></li><li>-XX:+PrintGCDetails<ul><li>打印GC详细信息</li></ul></li><li>-XX:SurvivorRatio=8<ul><li>Eden区和Survivor区的比例，8:1:1</li></ul></li><li>-XX:PretenureSizeThreshold=4194304<ul><li>当新生代对象初始大小超过阈值4M则直接在老年代进行分配，该配置项只能在串行GC收集器中生效</li></ul></li><li>-XX:+UseSerialGC<ul><li>使用串行GC，默认是ParallelGC</li></ul></li><li>-XX:MaxTenuringThreshold=5<ul><li>自动调节对象多少次GC后晋升(promote)到老年代中，阈值的最大值为5，jvm的GC可能在小于5时就让对象晋升（GC会计算每个对象的年龄，如果某个年龄后发现总大小已经大于了单个Survivor空间的50%，则该值会被自动调节，可能不会继续等到设置的最大值就完成多次存活对象的晋升），默认15(4bit存放)</li></ul></li><li>-XX:+PrintTenuringDistribution<ul><li>开启Tenuring对象信息（对象每次GC年龄会+1）</li></ul></li><li>-XX:TargetSurvivorRatio=60<ul><li>当其中一个Survivor空间被使用超过60%，则自动计算MaxTenuringThreshold值</li></ul></li><li>-XX:+PrintGCDateStamps<ul><li>打印GC时间信息</li></ul></li><li>-XX:+UseConcMarkSweepGC<ul><li>老年代使用CMS收集器</li></ul></li><li>-XX:+UseParNewGC<ul><li>新生代使用ParNew收集器</li></ul></li></ul></li><li><p>包含解释执行和编译执行混合模式</p><ul><li>解释执行：解释器不断读取字节码，碰到对应指令就解释执行</li><li>编译执行：通过JIT（just in time）即时编译器来讲字节码（热点代码）编译成本地机器码</li></ul></li><li><p>基于栈的指令集</p><ul><li>jvm是基于此，部分热点指令操作会做相关寄存器指令映射，从而提升指令操作效率</li><li>移植性好</li><li>基于内存操作，可能多个指令才能实现寄存器的一个指令操作</li></ul></li><li><p>基于寄存器的指令集</p><ul><li>速度更快，基于cpu高速缓存操作</li><li>更贴近硬件指令，指令更底层效率更高</li></ul></li></ul><h2 id="Run-time-data-area"><a href="#Run-time-data-area" class="headerlink" title="Run-time data area"></a>Run-time data area</h2><ul><li><img src="/imgs/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png" alt=""></li><li>PC：程序计数器，记录程序运行的指令地址，目的是线程切换后再次回来能知道线程运行到哪里，线程独享</li><li>Native Method Stacks：本地方法栈，线程独享</li><li>VM Stacks：vm虚拟机栈，存放栈帧(一个方法一个栈帧)，线程独享</li><li>Heap：堆，线程共享</li><li>Method Area：（Perm/Meta Space）方法区，线程共享<ul><li>jdk1.8之前称为永久代</li></ul></li><li>Const Pool：常量池，属于方法区，线程共享</li></ul><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><ul><li>GC的非主要工作区域</li><li>设置大小：-XX:MaxMetaSpaceSize=10m</li><li>元空间：每个类加载之后都会有其对应的元空间存储类字节（包括常量池、字段描述、方法描述等）等相关元数据，这些类元空间累计就是元空间大小<ul><li>元空间不够会出发Full GC，如果Full GC完之后可用空间过小或自动扩容，元空间属于本地内存，由元空间VM来管理</li><li>所以元空间大小需要设置为一个较高水位线，不然会出发多次Full GC</li></ul></li><li>回收内容<ul><li>废弃常量</li><li>无用类，同时满足3个条件<ol><li>该类的所有实例都被GC了</li><li>加载该类的ClassLoader被GC了</li><li>该类对应的java.lang.Class对象没有任何地方有引用，即不能有通过放射访问该类的地方</li></ol></li></ul></li></ul><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ul><li>设置栈大小：-Xss160k</li><li>栈中局部变量表中，引用访问对象的方式<ol><li>使用句柄的方式：直接指向一个句柄（可以理解为指针的抽象封装或描述符），句柄包含了引用对象的在方法区的元数据指针和堆中对象数据信息的指针</li><li>使用直接指针的方式：直接指针指向堆中对象数据信息，对象数据信息包含了对象的在方法区的元数据指针</li></ol></li></ul><h3 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h3><ul><li><img src="/imgs/heap.png" alt=""></li><li>传统heap结构：<img src="/imgs/heapstructure.png" alt=""></li><li>G1heap结构：<img src="/imgs/g1heapstructure.png" alt=""></li><li>设置堆内存最小最大值：-Xms5m -Xmx5m</li><li>new<ol><li>在heap中创建类的实例</li><li>为对象的成员变量赋初始值</li><li>将对象引用返回</li></ol><ul><li>指针碰撞：堆中空间通过指针进行划分，一边是已使用内存空间，另一边是未使用内存空间</li><li>空闲列表：由空闲列表维护内存空间使用记录，然后分配新的对象内存后同步维护空闲列表信息</li></ul></li></ul><h2 id="JVM垃圾回收"><a href="#JVM垃圾回收" class="headerlink" title="JVM垃圾回收"></a>JVM垃圾回收</h2><ul><li>如何判断需要回收：没有任何引用的对象</li></ul><h3 id="垃圾判断算法"><a href="#垃圾判断算法" class="headerlink" title="垃圾判断算法"></a>垃圾判断算法</h3><ol><li>引用计数：算法简单，但是容易出现循环依赖导致都无法回收</li><li>根搜索，正向可达：通过程序运行时产生的根对象(GC Roots)，依次正向寻找这些对象需要的依赖，能找到的都不回收，java采用的次算法<ul><li>GC Roots:JVM stack、方法区中的静态引用、JNI(Native Method Stacks)引用</li><li>枚举根节点是通过OopMap表来进行辅助实现的，OopMap会记录很多引用信息，很多指令都会导致引用信息变更，如果都需要同步OopMap会导致额外的空间成本</li><li>HotSpot并没有为每条指令都生成OopMap，而是在<strong>特定位置</strong>记录，这些位置成为<strong>安全点(Safepoint)</strong>,程序只有达到安全点后才能暂停来执行GC，并非所有时刻都可以暂停执行GC</li><li>Safepoint不能太少（会导致GC等待时间太长）也不能太多（会导致GC过于频繁），安全点的选定基本上是以<strong>是否具有让程序长时间运行的特征</strong>为标准的，<strong>长时间执行</strong>最明显的特征就是指令的复用，如：方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才能产生Safepoint</li><li>Safepoint另一个需要考虑的问题是如何在GC发生时让所有线程（不包括JNI调用线程）都“跑”到最近的安全点上暂停下来<ul><li>抢占式中断(Preemptive Suspention)<ul><li>不需要程序线程配合，GC发生时，首先让所有线程中断，如果有不在安全点上的线程，则恢复执行“跑”到安全点后再次中断</li></ul></li><li>主动式中断(Voluntary Suspention)<ul><li>当GC发生时，不直接操作程序线程，仅仅设置一个标志，各个线程会轮询这个标志，发现标志为真则主动中断挂起，轮询标志和安全点是重合的，另外再加上创建对象需要分配内存的地方也需要轮询</li><li>对于程序线程本身处于Sleep或Blocked状态时，没法主动轮询标志，此时需要<strong>安全区域(Safe Region)</strong>来处理</li><li>线程执行到安全区域时，标识自己已经进入此区域，jvm在GC时不会管理这类线程，线程离开安全区域时，会检查系统是否完全了GC Roots来判断自己是否可以继续执行</li></ul></li></ul></li><li>根对象：JVM stack，native method stack，run-time constant pool, static references in method area, Clazz</li></ul></li></ol><h3 id="垃圾清理算法"><a href="#垃圾清理算法" class="headerlink" title="垃圾清理算法"></a>垃圾清理算法</h3><ol><li>Mark-Sweep：标记清除<ul><li>标记所有需要回收的对象，然后清除所有被标记的对象</li><li>缺点<ol><li>效率问题，标记和清除2个过程效率都不高，需要扫描所有对象，heap越大，GC越慢</li><li>空间问题，容易产生碎片，导致没有连续的物理空间存放较大对象，影响性能，需要定时碎片整理</li></ol></li><li><img src="/imgs/Mark-Sweep.png" alt=""></li></ul></li><li>Copying：拷贝<ul><li>效率很高，将内存一分为二，新生代的surviv0+surviv1就是此算法实现，先将Eden和其中一个surviv区域不需要回收的对象拷贝到另外一个surviv区，同时还可以在另外一个surviv区压缩解决碎片化问题，然后将之前的Eden和surviv区域整个清理，针对垃圾比较多的情况，一般比例是8：1：1，这样可以保证浪费的内存只有10%</li><li>缺点<ol><li>成本非常高，可用内存损失一半</li></ol></li></ul></li><li>Mark-Compact：标记压缩<ul><li>在清理的时候同时进行未回收对象的压缩，让未回收的对象尽量在连续的物理空间，减少碎片化，效率会稍低，针对垃圾不多的情况</li></ul></li><li>Generational：分代算法<ul><li>目前主流GC算法，是1.2.3算法的结合体</li><li>将heap分为新生代和老年代<ul><li>新生代<ul><li>eden<ul><li>当eden满时，还存活的对象会被复制到from</li></ul></li><li>fromsurvivor</li><li>tosurvivor</li></ul></li><li>老年代<ul><li>存放了一次GC或多次GC还存活的对象</li><li>多种垃圾收集器可以选择，每种垃圾收集器对应一种算法的具体实现，不同算法的特点不一，表现为：吞吐量、效率等</li></ul></li><li>永久代<ul><li>jdk8之后已经剔除</li><li>并不属于heap，但是GC会涵盖这个区域</li><li>对应于jdk8之后的meta space</li></ul></li></ul></li><li><img src="/imgs/Generational.png" alt=""></li></ul></li></ol><h3 id="垃圾回收器的选择指标"><a href="#垃圾回收器的选择指标" class="headerlink" title="垃圾回收器的选择指标"></a>垃圾回收器的选择指标</h3><ol><li>吞吐量：GC时间占总运行时间最小，一段时间内，系统运行的任务量</li><li>响应能力：单次任务执行的时间</li><li>并发效率高</li><li>STW（stop the world）少</li></ol><h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><ul><li><img src="/imgs/gc%E6%94%B6%E9%9B%86%E5%99%A8.png" alt=""></li><li>并行和并发<ul><li>并行（Parallel）：指多个收集器的线程同时执行，但用户线程等待</li><li>并发（Concurrent）：收集器工作的同时，用户线程同时运行<ul><li>并不代表解决了GC停顿问题，关键的步骤用户线程还是停顿状态，比如收集器标记垃圾的时候，但清除和用户线程可以同时运行</li></ul></li></ul></li></ul><ol><li>Serial<ul><li>最早的收集器，收集时会STW（暂停所有用户线程），使用Copying算法</li><li>jvm在Client模式下默认新生代收集器</li><li>Young和Old都可以使用，Young中使用Copying算法，Old中使用Mark-Compact算法</li><li>单线程、简单实用</li></ul></li><li>ParNew<ul><li>Serial多线程版本</li><li>jvm在Server模式下默认的新生代收集器</li><li>可以通过-XX:ParallelGCThreads来控制GC线程数，需要根据硬件CPU个数来设定</li></ul></li><li>Parallel Scavenge<ul><li>多线程收集器，复制算法</li><li>对象分配规则、回收策略等都与ParNew有所不同</li><li>以吞吐量最大化为目标，允许STW换取总吞吐量最大化</li></ul></li><li>CMS(Concurrent Mark Sweep)<ul><li>以最短停顿时间为目标的收集器，多用于互联网网站或B/S系统的服务端</li><li>采用的是Mark-Sweep算法<ul><li>初始标记(CMS initial mark)<ul><li>会导致STW</li><li>只标记GC Roots直接关联的对象，速度很快</li></ul></li><li>并发标记(CMS concurrent mark)<ul><li>GC Roots Tracing，标记根可达的所有对象</li></ul></li><li>并发预先清理(CMS concurrent preclean)</li><li>并发可中正预清理(CMS concurrent abortable preclean)</li><li>重新标记(CMS remark)<ul><li>会导致STW</li><li>修正并发标记期间用户线程继续运作而导致标记产生变动的对象的标记记录，该过程比初始标记慢，但快于并发标记</li></ul></li><li>并发清除(CMS concurrent sweep)</li><li>并发重置(CMS concurrent reset)</li></ul></li><li>只针对于老年代，一般结合ParNew一起使用</li><li>Concurrent，GC线程和用户线程尽量并发工作</li><li>多CPU环境下才有意义，使用-XX:+UseConcMarkSweepGC打开</li><li>缺点<ul><li>CMS会更多的占用CPU资源</li><li>要保证用户线程并发运行，所以需要预留一部分空间给用户线程</li><li>有碎片化问题，可能导致频繁Full GC</li></ul></li></ul></li><li>G1<ul><li>Garbage First Collector</li><li>概念<ul><li>region：G1操作的heap的最小空间单元</li><li>CSet：收集集合，一组可被回收的region集合</li><li>RSet：RememberedSet已记忆集合<ul><li>记录了其他region中的对象引用了本region对象的关系(points-into谁引用了我)，会额外占用region空间，是通过对card table的points-out封装成hash table来完成RSet的points-into结构，card table记录的是引用其他region的指针</li><li><img src="/imgs/RSet.png" alt=""></li><li>新生代中的region无需进行RSet记录，因为默认新生代全局扫描</li></ul></li><li>Card table<ul><li>将分区划分成了固定大小的连续区域，每个区为卡</li></ul></li><li>三色标记算法<ul><li><img src="/imgs/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95.png" alt=""></li><li>黑色：根对象，或者该对象与其依赖对象都被扫描（成员变量引用的对象）</li><li>灰色：对象本身被扫描，其依赖对象没有被扫描</li><li>白色：未被扫描对象，即不可达对象（垃圾对象）</li><li>会导致与应用线程并发执行过程中导致标记错误，需要通过SATB来解决</li></ul></li><li>Snapshot-At-The-Beginning(SATB)<ul><li>在并发标记阶段使用的增量式标记算法</li><li>主要解决<ul><li>收集过程中，有新对象生成<ul><li>通过TAMS(top-at-mark-start)来判断对象是否新生成</li><li>region中有preTAMS和nextTAMS，在TAMS以上的就是新生成的，默认会被marked，认为是活的</li></ul></li><li>收集过程中，有对象引用变更</li></ul></li><li>开始标记时生成快照，标记存活对象</li><li>并发标记时记录对象引用改变记录（在write barrier读屏障里把所有旧的引用所指向的对象标为非白色）</li><li>可能存在浮动垃圾，下次将被收集</li></ul></li><li>Humongous<ul><li>存放巨型对象(对象大小大于region的50%)，如果一个H区无法满足，G1会找到连续区域来分配，如果没有，则会启动Full GC</li></ul></li></ul></li><li><img src="/imgs/g1heapstructure.png" alt=""><ul><li>heap被划分为一个个相等大小且不连续的内存区域(regions)，每个region都有一个角色：eden、survivor、old</li><li>每个角色的数量没有限定，可以动态变化</li></ul></li><li>适用于多核CPU、大内存容量的服务端系统</li><li>满足短时间GC停顿的同时达到较高吞吐量</li><li>jdk7以上适用</li><li>与CMS比较<ul><li>可以和应用线程同时执行，STW几乎不会发生同CMS</li><li>会自动整理剩余空间，不产生内存碎片（CMS只能在Full GC时，用STW的代价来整理，耗时更长）</li><li>G1停顿时间可控，用户可以配置，G1会进行参考</li><li>不牺牲系统吞吐量</li><li>G1不会产生浮动垃圾，需要额外的内存开销（CMS并发标记会导致浮动垃圾）</li></ul></li><li>采用Copying算法</li><li>高效执行回收，优先执行那些大量对象可回收的区域(region)即回收性价比高的region</li><li>垃圾多的region优先，名字由来G1</li><li>G1GC模式<ul><li>Young GC<ul><li>会STW</li><li>选定所有新生代的regions，通过控制region数量，来控制时间开销</li><li>步骤<ul><li>根扫描<ul><li>静态和本地对象被扫描</li></ul></li><li>更新RS<ul><li>处理dirty card队列更新RS</li></ul></li><li>处理RS<ul><li>检测从年轻代指向老年代的对象</li></ul></li><li>对象拷贝<ul><li>拷贝存活的对象到Survivor或Old区域</li></ul></li><li>处理引用队列<ul><li>软、弱、虚引用队列处理</li></ul></li></ul></li></ul></li><li>Mixed GC<ul><li>会STW</li><li>选定所有新生代regions，外加根据global concurrent marking统计得到回收性价比高的region，通过控制region数量，来控制时间开销</li><li>不是Full GC，只会回收部分老年代region</li><li>如果Mxied GC无法继续进行（对象创建速度大于回收速度），则会使用SerialOld GC(Full GC)来收集整个GC heap，所以本质上，G1不提供Full GC</li><li>global concurrent marking类似CMS，不同的是，它主要是服务Mixed GC，并不是GC过程的必要环节，分为4个步骤<ul><li>初始标记(initial mark STW)</li><li>并发标记(concurrent mark)</li><li>重新标记(remark STW)</li><li>清理(cleanup)</li></ul></li></ul></li></ul></li><li>G1主要模式<ul><li>YGC<ul><li>在Eden充满时触发，回收后region变为free region没有任何角色</li></ul></li><li>并发阶段</li><li>Mixed GC<ul><li>由参数控制触发，另外也控制这哪些老年代region被选入CSet中<ul><li>G1HeapWastePercent：在global concurrent marking之后，可以知道old region有多少需要被回收，在每次YGC之后和再次Mixed GC之前，会检查垃圾占比是否达到此参数，只有达到了，下次才会触发</li><li>G1MixedGCLiveThresholdPercent：old region中存活对象占比，在此之下会纳入CSet</li><li>G1MixedGCCountTarget：一次global concurrent marking之后，最多执行Mixed GC次数</li><li>G1OldCSetRegionThresholdPercent：一次Mixed GC中能被选入CSet最多的old region数量</li></ul></li></ul></li><li>Full GC（一般G1出现问题才发生）</li></ul></li><li>G1最佳实践<ul><li>优化应用程序暂停时间参数</li><li>不要设置新生代和老年代大小，G1有自动调节这2个区域大小的功能，并做了G1自带的优化，如果设置会影响G1的优化处理</li><li>重点关注Evacuation Failure，类似于CMS中的存活对象晋升失败，heap中垃圾太多导致region之间无法copying，此时G1不得不退化成Full GC</li></ul></li></ul></li></ol><h3 id="GC时机"><a href="#GC时机" class="headerlink" title="GC时机"></a>GC时机</h3><ul><li>Scavenge GC：Minor GC<ul><li>触发时机：新生代中新对象生成时，Eden满了</li><li>理论上Eden区大多数对象会在此GC回收</li></ul></li><li>Full GC<ul><li>对整个JVM整理，包括Yonng、Old和Perm</li><li>触发时机：Old满了、Perm满了、System.gc()</li><li>会STW，效率很低，尽量规避</li></ul></li></ul><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><pre><code>- 局部变量的声明放在了成员变量的位置，如果对象的存活时间过长，会导致成员变量的数据内存泄漏- io流或者jdbc等连接资源的关闭没有放在finally中，导致这些资源可能泄漏- 数组操作在初始化没有给定准确的数组长度，如果使用中涉及resize，会导致数组内容的copy扩容问题，如：ArrayList或HashMap，如果只是简单的顺序访问，不需要通过index随机访问，LinkedList效率更高，即使出现定义的长度不足，也不会resize，因为链表不需要连续内存空间</code></pre><h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><ul><li>在java代码中，类型的加载、连接、初始化过程都是在程序运行期间完成的</li><li>提供了更大的灵活性，增加了更多可能性<ol><li>加载<ul><li>查找并加载类的二进制数据</li><li>放入运行时数据区的方法区内</li></ul></li><li>连接<ul><li>验证：确保被加载的类的正确性</li><li>准备：为类的静态变量分配内存，并将其初始化为默认值</li><li>解析：把类中的符号引用转化为直接引用<ul><li>符号引用：包含语义信息，不涉及实现，同xml的namespace</li><li>直接引用：具体的实现，包含类的真实内存地址信息</li></ul></li></ul></li><li>初始化<ul><li>为类的静态变量赋予正确的初始值</li><li>初始化一个类时，不会初始化它所实现的接口</li><li>初始化一个接口是，也不会初始化它所继承的父接口</li></ul></li><li>使用<ul><li>类实例化</li><li>给实例化对象分配内存</li><li>给实例化对象变量赋默认值</li><li>给实例化对象变量赋给定的值</li><li>jvm会给每个类的实例生成至少一个初始化方法，这个初始化方法是&lt; init &gt;，每个构造方法都会生成一个&lt; init &gt;</li></ul></li><li>卸载<ul><li>jvm自带的加载器所加载的类是不会自动卸载的</li><li>只有用户定义的加载器关联的类能被卸载掉</li><li>GC或者类终止</li></ul></li></ol></li><li>所有jvm实现必须在每个类或接口被java程序”首次主动使用“时才初始化<ul><li>助记符（是通过java底层类实现助记符的功能）：可以通过<code>javap -c</code>命令进行反编译查看<ol><li>ldc：将int、float、string类型的常量从常量池推送到栈顶</li><li>bipush：将单字节-128~127的常量推送到栈顶</li><li>sipush：将双字节-32768~32767的常量推送到栈顶</li><li>iconst_m1<del>5：将int类型的-1</del>5推送到栈顶</li></ol></li></ul></li><li>java对类的使用分2种<ol><li>主动使用<ul><li>创建类的对象</li><li>访问类或接口的静态变量或方法</li><li>反射：Class.forName(“<em>.</em>.*”)</li><li>初始化子类</li><li>java启动类</li><li>动态语言支持，java.lang.invoke.MethodHandle实例解析的句柄对应的类</li></ul></li><li>被动使用<ul><li>其他情况属于被动使用</li></ul></li></ol></li></ul><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><ul><li><p>jvm自带加载器</p><ol><li>根类加载器（BootStrap）<ul><li><code>System.out.println(System.getProperty("sun.boot.class.path"));</code></li><li>负责加载jvm核心类库，如java.lang.*等，没有继承ClassLoader，jre/lib/rt.jar</li></ul></li><li>拓展加载器（Extension）<ul><li><code>System.out.println(System.getProperty("java.ext.dirs"));</code></li><li>父加载器是bootstrap，从java.ext.dirs系统属性指定的目录中加载类库，或者从jdk中jre/lib/ext加载，是纯java类，继承ClassLoader</li></ul></li><li>系统（应用）加载器（System/App）<ul><li><code>System.out.println(System.getProperty("java.class.path"));</code></li><li>父类是Extension，它从环境变量classpath或者系统属性java.class.path加载类库，它是用户自定义加载器的默认父加载器，纯java类，继承ClassLoader</li></ul></li></ol><ul><li>线程上下文加载器<ul><li>如果没有setContextClassLoader(ClassLoader cl),则默认获取的是父线程的上下文类加载器</li><li>spi（service provider interface 服务提供接口）场景常用<ul><li>jvm提供了spi，比如JDBC接口Connect、Statement或者JNDI等，具体的实现由不同厂商去实现</li><li>出现原因：提供的spi接口是有bootstrap加载器加载，但是厂商的实现是放在程序classpath下由app加载器处理，由于双亲委派原则，会导致bootstrap加载器无法对app加载器加载的类可见</li><li>处理方法：可以通过<code>Thread.currentThread().getContextClassLoader()</code>所指定的ClassLoader加载器获取其加载的类，改变了双亲委托原则</li></ul></li><li>使用方法：set-&gt;get-&gt;usr-&gt;reset</li><li>jdk1.6以后提供了ServiceLoader来进行spi接口以及实现类的加载，并保证这2者能相互可见，原理就是通过上下文加载器来完成的</li></ul></li></ul></li><li><p>用户自定义加载器</p><ul><li>必须是java.lang.ClassLoader的子类</li><li>可以定制类的加载方式</li></ul></li><li><p>jvm类加载器会在某个类即将被使用时预先加载它，如果预先加载碰到class文件丢失，类加载器会在<strong>程序首次主动使用</strong>该类时报告错误（LinkageError），如果一直没有主动使用则不会报错</p></li><li><p>类加载器把类加载到jvm中，jdk1.2开始类加载采用双亲委托机制，优先有父加载器加载，加载不了则自己加载，每个加载器有且仅有一个父加载器，bootstrap除外</p></li><li><p>每个类加载器都有命名空间</p><ul><li>是由该加载器和所有父加载器所加载的类构成的</li><li>所有父加载器无法加载到由子加载器命名空间的内容，反之可以</li><li>类命名空间不同会导致相同类加载到jvm多次</li><li>同一个命名空间的类相互可见</li><li>子加载器包含父加载器的命名空间</li><li>如果2个加载器之间没有直接或者间接父子关系，则各自加载的类相互不可见</li></ul></li></ul><h3 id="bytecode字节码"><a href="#bytecode字节码" class="headerlink" title="bytecode字节码"></a>bytecode字节码</h3><ul><li><p>整体结构</p><table><thead><tr><th align="center">类型</th><th align="center">名称</th><th align="center">说明</th><th align="center">长度</th></tr></thead><tbody><tr><td align="center">u4</td><td align="center">magic</td><td align="center">魔数，识别Class文件格式</td><td align="center">4个字节</td></tr><tr><td align="center">u2</td><td align="center">minor_version</td><td align="center">副版本号</td><td align="center">2个字节</td></tr><tr><td align="center">u2</td><td align="center">major_version</td><td align="center">主版本号</td><td align="center">2个字节</td></tr><tr><td align="center">u2</td><td align="center">constant_pool_count</td><td align="center">常量池计算器</td><td align="center">2个字节</td></tr><tr><td align="center">cp_info</td><td align="center">constant_pool</td><td align="center">常量池</td><td align="center">n个字节</td></tr><tr><td align="center">u2</td><td align="center">access_flags</td><td align="center">访问标志</td><td align="center">2个字节</td></tr><tr><td align="center">u2</td><td align="center">this_class</td><td align="center">类索引</td><td align="center">2个字节</td></tr><tr><td align="center">u2</td><td align="center">super_class</td><td align="center">父类索引</td><td align="center">2个字节</td></tr><tr><td align="center">u2</td><td align="center">interfaces_count</td><td align="center">接口计数器</td><td align="center">2个字节</td></tr><tr><td align="center">u2</td><td align="center">interfaces</td><td align="center">接口索引集合</td><td align="center">2个字节</td></tr><tr><td align="center">u2</td><td align="center">fields_count</td><td align="center">字段个数</td><td align="center">2个字节</td></tr><tr><td align="center">field_info</td><td align="center">fields</td><td align="center">字段集合</td><td align="center">n个字节</td></tr><tr><td align="center">u2</td><td align="center">methods_count</td><td align="center">方法计数器</td><td align="center">2个字节</td></tr><tr><td align="center">method_info</td><td align="center">methods</td><td align="center">方法集合</td><td align="center">m个字节</td></tr><tr><td align="center">u2</td><td align="center">attributes_count</td><td align="center">附加属性计数器</td><td align="center">2个字节</td></tr><tr><td align="center">attribute_info</td><td align="center">attributes</td><td align="center">attribute_info</td><td align="center">n个字节</td></tr></tbody></table></li><li><p>javap，jdk自带的字节码查看命令工具</p><ul><li>-c，显示助记符等信息</li><li>-verbose，显示更多信息，包括：字节码的魔数、版本号、常量池、类信息、类的构造方法、类中的方法信息、类变量、成员变量等<ul><li>魔数：所有的.class字节码文件的前4个字节都是魔数，魔数固定为：0x:<strong>CA FE BA BE</strong>,cafe babe咖啡宝贝，开创者自定义的</li><li>jdk版本信息：接下来的4个字节，前2个字节<strong>00 00</strong>表示minor version(次版本号)，后2个字节<strong>00 34</strong>表示major version(主版本号)，52.0，52对应jdk8，所以该字节表示jdk1.8.0</li><li>常量池（constant pool）：紧接着主版本号之后就是常量池入口，一个java类中定义的很多信息都是有常量池来维护和描述的，可以将常量池看做是Class文件的资源仓库，比如java类中定义的变量和方法信息，常量池中主要存储2类常量：字面量和符号引用<ul><li>常量池结构：主要由常量池数量和数组（表结构）组成</li><li>常量池数量：紧跟在主版本之后，占2个字节</li><li>常量池数组：紧跟在数量之后，数组中每个元素的第一个数据都是一个u1类型，占用1个字节，数组元素个数等于常量池数量-1，索引为0是保留常量，表示NULL，不体现在数组中</li><li>字面量：文本字符串，java中声明为final的常量值等</li><li>符号引用：类和接口的全局限定名，字段的名称和描述符，方法的名称和描述符等<ul><li>数据类型描述符：jvm都使用一个大写字母表示，如：B-byte,C-char,D-double,F-float,I-int,J-long,Z-boolean,V-void,L-对象类型,[-数组,[[-二维数组</li><li>方法描述符：优先参数列表后返回值，如：String hello(int id, String name) - (I,Ljava/lang/String;)Ljava/lang/String;</li><li>在类加载或第一次使用就转成了直接引用，这叫静态解析；还有一部分是由于java多态特性每次执行时动态转换为直接引用，这叫动态链接</li><li>方法重载：当前类的静态行为，静态分派</li><li>方法重写：当前类和父类的动态行为，涉及多态特性，动态分派</li><li>动态分派：区分类方法和接口方法动态分派<ul><li>virtual method table,vtable</li><li>interface method table,itable</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>栈帧</p><ul><li>是帮助jvm执行方法调用和方法执行的数据结构</li></ul></li></ul><h2 id="tuning入门-java对象分配"><a href="#tuning入门-java对象分配" class="headerlink" title="tuning入门-java对象分配"></a>tuning入门-java对象分配</h2><ul><li>栈上分配：出战之后对象自动清理，无需走GC<ol><li>线程私有小对象</li><li>无逃逸</li><li>支持标量替换</li><li>无需调整</li></ol></li><li>线程本地分配TLAB（Thread Local Allocation Buffer）<ol><li>占用Eden区内存，默认1%</li><li>多线程时不用竞争eden就可以申请空间，提高效率</li><li>小对象</li><li>无需调整</li></ol></li><li>老年代<ol><li>大对象</li></ol></li><li>Eden</li></ul><h3 id="jvm相关调试工具"><a href="#jvm相关调试工具" class="headerlink" title="jvm相关调试工具"></a>jvm相关调试工具</h3><ul><li>jfr:java flight recoder，java飞行记录器</li><li>jmx:java manager extension，java管理扩展</li></ul><ol><li>GUI(可视化)工具<ol><li>jconsole</li><li>jvisualvm</li><li>jmc<ul><li>java mission control:java任务控制</li></ul></li></ol></li><li>命令工具<ol><li>jmap<ul><li>类加载器查看：<code>jmap -clstats pid</code></li><li>查看堆信息：<code>jmap -heap pid</code></li></ul></li><li>jstat<ul><li>查看元空间信息：jstat -gc jvmid</li></ul></li><li>jcmd<ul><li>获取java进程可执行的操作：jcmd pid help</li><li>获取java进程可执行的操作参数：jcmd pid help VM.flags</li><li>获取java进程的VM参数信息：jcmd pid VM.flags</li><li>查看jvm性能相关参数：jcmd pid PerCounter.print</li><li>查看jvm启动时长：jcmd pid VM.uptime</li><li>查看系统中类的统计信息：jcmd pid GC.class_histogram</li><li>查看线程的堆栈信息：jcmd pid Thread.print</li><li>导出heapdump文件：jcmd pid GC.heap_dump path/filename.hprof</li><li>查看JVM属性信息：jcmd pid VM.system_properties</li><li>查看目标jvm版本信息：jcmd pid VM.version</li><li>查看jvm启动的命令行参数：jcmd pid VM.command_line</li></ul></li><li>jps<ul><li>获取jvm中进程pid和java信息</li></ul></li><li>jstack<ul><li>查看或是导出java程序中线程的堆栈信息</li><li>jstack pid</li></ul></li><li>jhat<ul><li>分析堆转储文件，jhat path/filename.hprof，该命令会开启一个http服务，可以通过访问服务来分析hprof信息</li></ul></li></ol></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yws micro service platform</title>
      <link href="/2019/11/11/xue-xi-pian/yws-micro-service-platform/"/>
      <url>/2019/11/11/xue-xi-pian/yws-micro-service-platform/</url>
      
        <content type="html"><![CDATA[<h2 id="gradle"><a href="#gradle" class="headerlink" title="gradle"></a>gradle</h2><p>groovy实现的java构建工具<br>无法实现maven的多级子项目创建</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> micro service </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Security OAuth2</title>
      <link href="/2019/11/07/xue-xi-pian/spring-security-oauth2/"/>
      <url>/2019/11/07/xue-xi-pian/spring-security-oauth2/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-Security-OAuth2"><a href="#Spring-Security-OAuth2" class="headerlink" title="Spring Security OAuth2"></a>Spring Security OAuth2</h2><hr><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1 基本概念"></a>1 基本概念</h3><hr><h3 id="1-1-认证"><a href="#1-1-认证" class="headerlink" title="1.1 认证"></a>1.1 认证</h3><p>身份认证</p><h3 id="1-2-授权"><a href="#1-2-授权" class="headerlink" title="1.2 授权"></a>1.2 授权</h3><p>认证后资源访问权限</p><h3 id="1-3-授权数据模型"><a href="#1-3-授权数据模型" class="headerlink" title="1.3 授权数据模型"></a>1.3 授权数据模型</h3><p>WWH：Who对What(Which)进行How操作<br>Who：主体（Subject)，如：用户、程序<br>What：资源（Resource)<br>How：权限/许可（Permission）</p><h3 id="1-4-RBAC（Role-Resource-Based-Access-Control）"><a href="#1-4-RBAC（Role-Resource-Based-Access-Control）" class="headerlink" title="1.4 RBAC（Role/Resource-Based Access Control）"></a>1.4 RBAC（Role/Resource-Based Access Control）</h3><ul><li>基于角色的访问控制</li><li>基于资源的访问控制<h3 id="2-Spring-Security"><a href="#2-Spring-Security" class="headerlink" title="2 Spring Security"></a>2 Spring Security</h3></li></ul><hr><h3 id="2-1-工作原理"><a href="#2-1-工作原理" class="headerlink" title="2.1 工作原理"></a>2.1 工作原理</h3><pre><code>由filter链来进行处理，每个请求进来都会走一个filter链核心的几个链：认证的filter+授权filter</code></pre><h3 id="2-2-认证流程"><a href="#2-2-认证流程" class="headerlink" title="2.2 认证流程"></a>2.2 认证流程</h3><h3 id="2-2-1-AuthenticationProvider"><a href="#2-2-1-AuthenticationProvider" class="headerlink" title="2.2.1 AuthenticationProvider"></a>2.2.1 AuthenticationProvider</h3><h3 id="2-2-2-UserDetailService"><a href="#2-2-2-UserDetailService" class="headerlink" title="2.2.2 UserDetailService"></a>2.2.2 UserDetailService</h3><h3 id="2-2-3-PasswordEncoder"><a href="#2-2-3-PasswordEncoder" class="headerlink" title="2.2.3 PasswordEncoder"></a>2.2.3 PasswordEncoder</h3><h3 id="3-分布式系统认证方案"><a href="#3-分布式系统认证方案" class="headerlink" title="3 分布式系统认证方案"></a>3 分布式系统认证方案</h3><hr><h3 id="3-1-分布式系统"><a href="#3-1-分布式系统" class="headerlink" title="3.1 分布式系统"></a>3.1 分布式系统</h3><ul><li>分布性：每个部分可以独立部署，模块之间通过网络进行通信</li><li>伸缩性：每个部分可以集群方式部署，可以针对部分节点进行硬件或软件扩容</li><li>共享性：每个部分可以作为共享资源对外提供服务，多个部分可能操作共享资源</li><li>开放性：每个部分可以对外发布共享资源访问接口，允许第三方系统接入<h3 id="3-2-分布式认证需求"><a href="#3-2-分布式认证需求" class="headerlink" title="3.2 分布式认证需求"></a>3.2 分布式认证需求</h3></li><li>统一认证授权</li><li>应用接入授权<h3 id="3-3-分布式认证方案"><a href="#3-3-分布式认证方案" class="headerlink" title="3.3 分布式认证方案"></a>3.3 分布式认证方案</h3></li><li>基于session的认证</li><li>基于token的认证（以此方案为准）<h3 id="4-OAuth2-0"><a href="#4-OAuth2-0" class="headerlink" title="4 OAuth2.0"></a>4 OAuth2.0</h3></li></ul><hr><h3 id="4-1-OAuth2-0介绍"><a href="#4-1-OAuth2-0介绍" class="headerlink" title="4.1 OAuth2.0介绍"></a>4.1 OAuth2.0介绍</h3><p>它是一个开放标准，允许用户授权第三方应用访问他们存储在另外服务提供者上的用户本人相关信息，而不需要将用户和密码提供给第三方应用或分享用户数据的所有内容。<br>例如：用户A通过授权新浪博客访问用户A在微信服务上的身份信息，这样用户A就可以通过微信登录成功验证后直接无账号访问新浪博客<br>流程：用户A访问新浪微博登录页==》新浪微博登录页请求微信认证==》微信返回用户A是否授权页面==》用户A确认==》新浪微博获取到微信返回的授权码==》新浪微博通过授权码向微信申请令牌==》微信成功返回令牌==》新浪微博向微信请求用户信息==》微信校验令牌合法性返回用户信息==》新浪微博显示用户信息然后正常访问新浪相关服务<br>OAuth2.0包含的角色</p><ul><li>客户端：浏览器等</li><li>资源拥有者：用户A</li><li>授权服务器：微信认证服务器，会同时校验<strong>客户端</strong>和<strong>资源拥有者</strong>是否都合法</li><li>资源服务器：微信存储的用户信息<h3 id="4-2-Spring-Cloud-Security-OAuth2-0"><a href="#4-2-Spring-Cloud-Security-OAuth2-0" class="headerlink" title="4.2 Spring Cloud Security OAuth2.0"></a>4.2 Spring Cloud Security OAuth2.0</h3></li><li>授权服务（Authorization Server）<br>AuthorizationEndPoint服务于认证请求。默认URL：/oauth/authorize<br>TokenEndPoint服务于访问令牌请求。默认URL：/oauth/token</li><li>资源服务（Resource Server）</li><li>OAuth2AuthenticationProcessingFilter用来对请求的令牌进行解析校验<h3 id="4-3-授权服务配置"><a href="#4-3-授权服务配置" class="headerlink" title="4.3 授权服务配置"></a>4.3 授权服务配置</h3>令牌存储方式</li><li>InMemoryTokenStore</li><li>JdbcTokenStore</li><li>JwtTokenStore：Json WebToken</li><li>总结：要完成认证，需要知道客户端详情配置==》token的相关端点及如何存储，客户端支持哪些类型token==》对暴露在外的端点进行安全策略配置<br>四种模式</li><li>授权码模式<br>/uaa/oauth/authorize?client_id=c1&amp;response_type=code&amp;scope=all&amp;redirect_uri=<a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a><br>/uaa/oauth/token?client_id=c1&amp;client_secret=secret&amp;grant_type=authorization_code&amp;code=<em>&amp;^</em>^yyi*&amp;redirect_uri=<a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a></li><li>简化模式<br>/uaa/oauth/authorize?client_id=c1&amp;response_type=token&amp;scope=all&amp;redirect_uri=<a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a></li><li>密码模式<br>/uaa/oauth/token?client_id=c1&amp;client_secret=secret&amp;grant_type=password&amp;username=zhangsan&amp;password=123&amp;redirect_uri=<a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a></li><li>客户端模式<br>/uaa/oauth/token?client_id=c1&amp;client_secret=secret&amp;grant_type=client_credentials&amp;redirect_uri=<a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a><h3 id="4-4-资源服务配置"><a href="#4-4-资源服务配置" class="headerlink" title="4.4 资源服务配置"></a>4.4 资源服务配置</h3>资源访问校验会与认证服务交互获取，所以需要在资源服务配置中增加认证服务uri设置</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> oauth2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ocp系统</title>
      <link href="/2019/11/07/xue-xi-pian/ocp-xi-tong/"/>
      <url>/2019/11/07/xue-xi-pian/ocp-xi-tong/</url>
      
        <content type="html"><![CDATA[<h2 id="lombok"><a href="#lombok" class="headerlink" title="lombok"></a>lombok</h2><ul><li>简化实体类的编码，编译后自动生成set、get器等重复性代码，开发时可忽略</li><li>@Data</li><li>@Builder</li><li>@Setter</li><li>@Getter<h2 id="Oahth"><a href="#Oahth" class="headerlink" title="Oahth"></a>Oahth</h2>开放身份认证授权标准<br>spring security安全验证框架，对oauth标准的实现<h2 id="kaptcha"><a href="#kaptcha" class="headerlink" title="kaptcha"></a>kaptcha</h2>google图形验证码 <h2 id="springcloud"><a href="#springcloud" class="headerlink" title="springcloud"></a>springcloud</h2>将xml配置进行java对象化</li></ul><h2 id="验证码功能"><a href="#验证码功能" class="headerlink" title="验证码功能"></a>验证码功能</h2><ul><li>页面通过url请求服务器生成验证码，同时通过redis进行持久化<h2 id="swagger"><a href="#swagger" class="headerlink" title="swagger"></a>swagger</h2></li><li>默认访问地址：<a href="http://localhost:8080/pay/swagger-ui.html" target="_blank" rel="noopener">http://localhost:8080/pay/swagger-ui.html</a></li><li>restful API接口框架<ul><li>自动生成接口文档</li><li>接口测试</li></ul></li><li>集成springboot<ol><li>进行swagger静态资源映射，不然会直接走sevlet对应的controller</li><li>进行swagger的配置，设置需要生成api文档的restful请求</li><li>需要在需要swagger管理的controller中配置注解</li></ol><ul><li>@ApiOperation:用在方法上，说明方法的作用</li><li>@ApiImplicitParams:用在方法上包含一组参数说明</li><li>@ApiImplicitParam:用在@ApiImplicitParams中，指定一个请求参数的说明<ul><li>paramType<ul><li>header -&gt; @RequestHeader,请求头</li><li>query -&gt; @RequestParam,get请求参数url?a=1&amp;b=2</li><li>path -&gt; @PathVariable,restful接口即controller中/path/{param}</li><li>body -&gt; @RequestBody,json参数</li><li>form -&gt; 表单提交,页面submit提交参数</li></ul></li></ul></li></ul></li></ul><h2 id="xxl-job"><a href="#xxl-job" class="headerlink" title="xxl-job"></a>xxl-job</h2><h2 id="ocp部署"><a href="#ocp部署" class="headerlink" title="ocp部署"></a>ocp部署</h2><p>- </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> micro service </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssh原理</title>
      <link href="/2019/11/07/zhuan-ye-pian/ssh-yuan-li/"/>
      <url>/2019/11/07/zhuan-ye-pian/ssh-yuan-li/</url>
      
        <content type="html"><![CDATA[<h2 id="搭建免密访问"><a href="#搭建免密访问" class="headerlink" title="搭建免密访问"></a>搭建免密访问</h2><h3 id="通过rsa非对称算法生成相关信息"><a href="#通过rsa非对称算法生成相关信息" class="headerlink" title="通过rsa非对称算法生成相关信息"></a>通过rsa非对称算法生成相关信息</h3><ul><li>ssh-keygen -t rsa -P ‘’<pre><code>      - 会自动在~目录下生成.ssh文件夹，包含下列文件信息</code></pre></li><li>authorized_keys<ul><li>存放远程免密登录的公钥,主要通过这个文件记录多台机器的公钥</li></ul></li><li>id_rsa<ul><li>生成的私钥文件</li></ul></li><li>id_rsa.pub<ul><li>生成的公钥文件</li></ul></li><li>know_hosts<ul><li>已知的主机公钥清单<h3 id="如果希望ssh公钥生效需满足至少下面两个条件："><a href="#如果希望ssh公钥生效需满足至少下面两个条件：" class="headerlink" title="如果希望ssh公钥生效需满足至少下面两个条件："></a>如果希望ssh公钥生效需满足至少下面两个条件：</h3></li></ul></li><li>.ssh目录的权限必须是700</li><li>.ssh/authorized_keys文件权限必须是600<h3 id="实现双向免登陆"><a href="#实现双向免登陆" class="headerlink" title="实现双向免登陆"></a>实现双向免登陆</h3></li><li>A免登陆B<ul><li>将A机器上生成的pub文件拷贝到B服务器</li><li>然后将pub文件转成authorized_keys认证文件</li><li>将pub文件信息追加到authorized_keys中</li><li>cat pub &gt;&gt; authorized_keys</li></ul></li><li>B免登录A<ul><li>将B机器上生成的pub文件拷贝到A服务器</li><li>然后将pub文件转成authorized_keys认证文件</li><li>know_hosts</li><li>如果B事先增加了A的pub公钥信息，则A机器首次免密码登录B时不会有提示是否连接</li><li>反之亦反</li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> ssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区块链概念</title>
      <link href="/2019/11/07/xue-xi-pian/qu-kuai-lian-gai-nian/"/>
      <url>/2019/11/07/xue-xi-pian/qu-kuai-lian-gai-nian/</url>
      
        <content type="html"><![CDATA[<h2 id="比特币"><a href="#比特币" class="headerlink" title="比特币"></a>比特币</h2><h3 id="是一种数字或者叫电子货币"><a href="#是一种数字或者叫电子货币" class="headerlink" title="是一种数字或者叫电子货币"></a>是一种数字或者叫电子货币</h3><h3 id="去中心化的点对点（P2P）电子记账系统"><a href="#去中心化的点对点（P2P）电子记账系统" class="headerlink" title="去中心化的点对点（P2P）电子记账系统"></a>去中心化的点对点（P2P）电子记账系统</h3><h2 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h2><h3 id="由比特币衍生出来的一个概念"><a href="#由比特币衍生出来的一个概念" class="headerlink" title="由比特币衍生出来的一个概念"></a>由比特币衍生出来的一个概念</h3><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><ul><li>ABCD相互交易</li><li>A给B10个比特币，该交易记录A会广播出去让BCD都知道</li><li>同理BCD的交易记录也会广播到所有用户</li><li>这些交易记录会打包成一个块（<strong>区块</strong>）</li><li>每个区块大小1M，可以存储4000多条交易记录</li><li>每个新块会链接到之前的老块上就形成了<strong>区块链</strong></li></ul><h2 id="挖矿原理"><a href="#挖矿原理" class="headerlink" title="挖矿原理"></a>挖矿原理</h2><ul><li>哈希算法（sha256）</li><li>通过对一个字符串进行2次哈希运算</li><li>字符串：前区块的头部+交易信息+其他信息+时间戳+随机数</li><li>挖矿规则：通过改变随机数让最后计算出的hash值前n为都为0则表示挖矿成功</li><li>难度系数：n个位数</li></ul><h2 id="区块链需要考虑的问题"><a href="#区块链需要考虑的问题" class="headerlink" title="区块链需要考虑的问题"></a>区块链需要考虑的问题</h2><ul><li>区块以谁为准</li><li>为什么要记账</li><li>如何防伪和防篡改</li></ul><h3 id="为什么记账"><a href="#为什么记账" class="headerlink" title="为什么记账"></a>为什么记账</h3><ul><li>会有额外奖励，每次交易会额外增加手续费，同时打包区块也有奖励</li></ul><h3 id="比特币总数"><a href="#比特币总数" class="headerlink" title="比特币总数"></a>比特币总数</h3><ul><li>每4年打包奖励减半，从50个比特币开始依次类推</li><li>每10分钟允许打包一次</li><li>50<em>6</em>24<em>365</em>4*（1+1/2+1/4+…）= 2100w左右</li></ul><h3 id="以谁为准"><a href="#以谁为准" class="headerlink" title="以谁为准"></a>以谁为准</h3><ul><li>工作量证明，解决一个数学题，谁先解决就以谁为准进行打包</li></ul><h3 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h3><ul><li>ras非对称算法安全性保证</li><li>每个用户都可以通过申请得到一个私钥，每次交易记录进行广播都会进行加密</li><li>发送方：交易记录+摘要（通过对交易记录进行hash运算）+密文（通过对摘要进行私钥加密）</li><li>广播内容：交易记录+公钥+密文</li><li>接收方：对交易记录进行hash运算得到摘要+通过公钥和密文进行解密得到摘要，比对2个摘要是否相等</li></ul><h3 id="余额检查"><a href="#余额检查" class="headerlink" title="余额检查"></a>余额检查</h3><ul><li>通过追溯的方式进行区块主链上交易记录进行用户比特币余额计算</li></ul><h3 id="双重支付"><a href="#双重支付" class="headerlink" title="双重支付"></a>双重支付</h3><ul><li>余额为10比特币，同时发送交易记录给A，B</li><li>其他所有用户可能有部分接受到的交易记录是给A，有点给B</li><li>等到某个用户挖到矿打包区块的时候会根据该用户接受到的交易记录为准，另一条作废</li><li>比特币的交易需要过几个区块才能确定是否成功</li></ul><h3 id="防止篡改"><a href="#防止篡改" class="headerlink" title="防止篡改"></a>防止篡改</h3><ul><li>区块链需要满足最长链路原则</li><li>如果已经有3个区块，某用户想修改第二个区块内的交易信息</li><li>必须在第二个区块进行重新打包，同时要打包出第三个区块、第四个区块…</li><li>还需要该进度快于已经存在的3个区块打包进度</li><li>难度：以个人之力对抗所有用户挖矿能力</li><li>其他所有用户都在主链上挖矿，个人需要开辟新分支进行单独挖矿</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx小记</title>
      <link href="/2019/10/16/zhuan-ye-pian/nginx-xiao-ji/"/>
      <url>/2019/10/16/zhuan-ye-pian/nginx-xiao-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="配置nginx-conf"><a href="#配置nginx-conf" class="headerlink" title="配置nginx.conf"></a>配置nginx.conf</h2><pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true">#定义Nginx运行的用户和用户组</span><span class="token attr-name">user</span> <span class="token attr-value">www www; </span><span class="token comment" spellcheck="true">#nginx进程数，通常设置成和cpu的数量相等</span><span class="token attr-name">worker_processes</span> <span class="token attr-value">4; </span><span class="token comment" spellcheck="true">#全局错误日志定义类型，[debug | info | notice | warn | error | crit]</span><span class="token comment" spellcheck="true">#error_log  logs/error.log;</span><span class="token comment" spellcheck="true">#error_log  logs/error.log  notice;</span><span class="token comment" spellcheck="true">#error_log  logs/error.log  info;</span><span class="token comment" spellcheck="true">#进程pid文件</span><span class="token comment" spellcheck="true">#pid        logs/nginx.pid;</span><span class="token comment" spellcheck="true">#指定进程可以打开的最大描述符：数目</span><span class="token comment" spellcheck="true">#工作模式与连接数上限</span><span class="token comment" spellcheck="true">##这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n 的值保持一致。</span><span class="token comment" spellcheck="true">#这是因为nginx调度时分配请求到进程并不是那么的均衡，所以假如填写10240，总并发量达到3-4万时就有进程可能超过10240了，这时会返回502错误。</span><span class="token attr-name">worker_rlimit_nofile</span> <span class="token attr-value">65535;</span><span class="token attr-name">events</span> <span class="token attr-value">{</span><span class="token comment" spellcheck="true">    #参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型</span><span class="token comment" spellcheck="true">    #是Linux 2.6以上版本内核中的高性能网络I/O模型，linux建议epoll，如果跑在FreeBSD上面，就用kqueue模型。</span><span class="token comment" spellcheck="true">    #补充说明：</span><span class="token comment" spellcheck="true">    #与apache相类，nginx针对不同的操作系统，有不同的事件模型</span><span class="token comment" spellcheck="true">    #A）标准事件模型</span><span class="token comment" spellcheck="true">    #Select、poll属于标准事件模型，如果当前系统不存在更有效的方法，nginx会选择select或poll</span><span class="token comment" spellcheck="true">    #B）高效事件模型</span><span class="token comment" spellcheck="true">    #Kqueue：使用于FreeBSD 4.1+, OpenBSD 2.9+, NetBSD 2.0 和 MacOS X.使用双处理器的MacOS X系统使用kqueue可能会造成内核崩溃。</span><span class="token comment" spellcheck="true">    #Epoll：使用于Linux内核2.6版本及以后的系统。</span><span class="token comment" spellcheck="true">    #/dev/poll：使用于Solaris 7 11/99+，HP/UX 11.22+ (eventport)，IRIX 6.5.15+ 和 Tru64 UNIX 5.1A+。</span><span class="token comment" spellcheck="true">    #Eventport：使用于Solaris 10。 为了防止出现内核崩溃的问题， 有必要安装安全补丁。</span><span class="token attr-name">    use</span> <span class="token attr-value">epoll</span><span class="token comment" spellcheck="true">    #单个进程最大连接数（最大连接数=连接数+进程数）</span><span class="token comment" spellcheck="true">    #根据硬件调整，和前面工作进程配合起来用，尽量大，但是别把cup跑到100%就行。</span><span class="token attr-name">    worker_connections</span> <span class="token attr-value"> 1024;</span><span class="token comment" spellcheck="true">    #keepalive 超时时间</span><span class="token attr-name">    keepalive_timeout</span> <span class="token attr-value">60;</span><span class="token comment" spellcheck="true">    #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求头的大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。</span><span class="token comment" spellcheck="true">    #分页大小可以用命令getconf PAGESIZE 取得。</span><span class="token comment" spellcheck="true">    #[root@web001 ~]# getconf PAGESIZE</span><span class="token comment" spellcheck="true">    #但也有client_header_buffer_size超过4k的情况，但是client_header_buffer_size该值必须设置为“系统分页大小”的整倍数。</span><span class="token attr-name">    client_header_buffer_size</span> <span class="token attr-value">4k;</span><span class="token comment" spellcheck="true">    #这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。</span><span class="token attr-name">    open_file_cache</span> <span class="token attr-value">max=65535 inactive=60s;</span><span class="token comment" spellcheck="true">    #这个是指多长时间检查一次缓存的有效信息。</span><span class="token comment" spellcheck="true">    #语法:open_file_cache_valid time 默认值:open_file_cache_valid 60 使用字段:http, server, location 这个指令指定了何时需要检查open_file_cache中缓存项目的有效信息.</span><span class="token attr-name">    open_file_cache_valid</span> <span class="token attr-value">80s;</span><span class="token comment" spellcheck="true">    #open_file_cache指令中的inactive参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive时间内一次没被使用，它将被移除。</span><span class="token comment" spellcheck="true">    #语法:open_file_cache_min_uses number 默认值:open_file_cache_min_uses 1 使用字段:http, server, location  这个指令指定了在open_file_cache指令无效的参数中一定的时间范围内可以使用的最小文件数,如果使用更大的值,文件描述符在cache中总是打开状态.</span><span class="token attr-name">    open_file_cache_min_uses</span> <span class="token attr-value">1;</span><span class="token comment" spellcheck="true">    #语法:open_file_cache_errors on | off 默认值:open_file_cache_errors off 使用字段:http, server, location 这个指令指定是否在搜索一个文件是记录cache错误.</span><span class="token attr-name">    open_file_cache_errors</span> <span class="token attr-value">on;</span>}<span class="token comment" spellcheck="true">#设定http服务器，利用它的反向代理功能提供负载均衡支持</span>http{<span class="token comment" spellcheck="true">    #文件扩展名与文件类型映射表</span><span class="token attr-name">    include</span> <span class="token attr-value">mime.types;</span><span class="token comment" spellcheck="true">    #默认文件类型</span><span class="token attr-name">    default_type</span> <span class="token attr-value">application/octet-stream;</span><span class="token comment" spellcheck="true">    #默认编码</span><span class="token attr-name">    charset</span> <span class="token attr-value">utf-8;</span><span class="token comment" spellcheck="true">    #服务器名字的hash表大小</span><span class="token comment" spellcheck="true">    #保存服务器名字的hash表是由指令server_names_hash_max_size 和server_names_hash_bucket_size所控制的。参数hash bucket size总是等于hash表的大小，并且是一路处理器缓存大小的倍数。在减少了在内存中的存取次数后，使在处理器中加速查找hash表键值成为可能。如果hash bucket size等于一路处理器缓存的大小，那么在查找键的时候，最坏的情况下在内存中查找的次数为2。第一次是确定存储单元的地址，第二次是在存储单元中查找键 值。因此，如果Nginx给出需要增大hash max size 或 hash bucket size的提示，那么首要的是增大前一个参数的大小.</span><span class="token attr-name">    server_names_hash_bucket_size</span> <span class="token attr-value">128;</span><span class="token comment" spellcheck="true">    #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求的头部大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。分页大小可以用命令getconf PAGESIZE取得。</span><span class="token attr-name">    client_header_buffer_size</span> <span class="token attr-value">32k;</span><span class="token comment" spellcheck="true">    #客户请求头缓冲大小。nginx默认会用client_header_buffer_size这个buffer来读取header值，如果header过大，它会使用large_client_header_buffers来读取。</span><span class="token attr-name">    large_client_header_buffers</span> <span class="token attr-value">4 64k;</span><span class="token comment" spellcheck="true">    #设定通过nginx上传文件的大小</span><span class="token attr-name">    client_max_body_size</span> <span class="token attr-value">8m;</span><span class="token comment" spellcheck="true">    #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。</span><span class="token comment" spellcheck="true">    #sendfile指令指定 nginx 是否调用sendfile 函数（zero copy 方式）来输出文件，对于普通应用，必须设为on。如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络IO处理速度，降低系统uptime。</span><span class="token attr-name">    sendfile</span> <span class="token attr-value">on;</span><span class="token comment" spellcheck="true">     #开启目录列表访问，合适下载服务器，默认关闭。</span><span class="token attr-name">    autoindex</span> <span class="token attr-value">on;</span><span class="token comment" spellcheck="true">      #此选项允许或禁止使用socke的TCP_CORK的选项，此选项仅在使用sendfile的时候使用</span><span class="token attr-name">    tcp_nopush</span> <span class="token attr-value">on;</span><span class="token attr-name">    tcp_nodelay</span> <span class="token attr-value">on;</span><span class="token comment" spellcheck="true">    #长连接超时时间，单位是秒</span><span class="token attr-name">    keepalive_timeout</span> <span class="token attr-value">120;</span><span class="token comment" spellcheck="true">    #FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。</span><span class="token attr-name">    fastcgi_connect_timeout</span> <span class="token attr-value">300;</span><span class="token attr-name">    fastcgi_send_timeout</span> <span class="token attr-value">300;</span><span class="token attr-name">    fastcgi_read_timeout</span> <span class="token attr-value">300;</span><span class="token attr-name">    fastcgi_buffer_size</span> <span class="token attr-value">64k;</span><span class="token attr-name">    fastcgi_buffers</span> <span class="token attr-value">4 64k;</span><span class="token attr-name">    fastcgi_busy_buffers_size</span> <span class="token attr-value">128k;</span><span class="token attr-name">    fastcgi_temp_file_write_size</span> <span class="token attr-value">128k;</span><span class="token comment" spellcheck="true">    #gzip模块设置</span><span class="token attr-name">    gzip</span> <span class="token attr-value">on; #开启gzip压缩输出</span><span class="token attr-name">    gzip_min_length</span> <span class="token attr-value">1k;    #最小压缩文件大小</span><span class="token attr-name">    gzip_buffers</span> <span class="token attr-value">4 16k;    #压缩缓冲区</span><span class="token attr-name">    gzip_http_version</span> <span class="token attr-value">1.0; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0）</span><span class="token attr-name">    gzip_comp_level</span> <span class="token attr-value">2;     #压缩等级</span><span class="token attr-name">    gzip_types</span> <span class="token attr-value">text/plain application/x-javascript text/css application/xml;    #压缩类型，默认就已经包含textml，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。</span><span class="token attr-name">    gzip_vary</span> <span class="token attr-value">on;</span><span class="token comment" spellcheck="true">    #开启限制IP连接数的时候需要使用</span><span class="token comment" spellcheck="true">    #limit_zone crawler $binary_remote_addr 10m;</span><span class="token comment" spellcheck="true">    #负载均衡配置</span><span class="token attr-name">    upstream</span> <span class="token attr-value">piao.jd.com {</span><span class="token comment" spellcheck="true">        #upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。</span><span class="token attr-name">        server</span> <span class="token attr-value">192.168.80.121:80 weight=3;</span><span class="token attr-name">        server</span> <span class="token attr-value">192.168.80.122:80 weight=2;</span><span class="token attr-name">        server</span> <span class="token attr-value">192.168.80.123:80 weight=3;</span><span class="token comment" spellcheck="true">        #nginx的upstream目前支持4种方式的分配</span><span class="token comment" spellcheck="true">        #1、轮询（默认）</span><span class="token comment" spellcheck="true">        #每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</span><span class="token comment" spellcheck="true">        #2、weight</span><span class="token comment" spellcheck="true">        #指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</span><span class="token comment" spellcheck="true">        #例如：</span><span class="token comment" spellcheck="true">        #upstream bakend {</span><span class="token comment" spellcheck="true">        #    server 192.168.0.14 weight=10;</span><span class="token comment" spellcheck="true">        #    server 192.168.0.15 weight=10;</span><span class="token comment" spellcheck="true">        #}</span><span class="token comment" spellcheck="true">        #2、ip_hash</span><span class="token comment" spellcheck="true">        #每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。</span><span class="token comment" spellcheck="true">        #例如：</span><span class="token comment" spellcheck="true">        #upstream bakend {</span><span class="token comment" spellcheck="true">        #    ip_hash;</span><span class="token comment" spellcheck="true">        #    server 192.168.0.14:88;</span><span class="token comment" spellcheck="true">        #    server 192.168.0.15:80;</span><span class="token comment" spellcheck="true">        #}</span><span class="token comment" spellcheck="true">        #3、fair（第三方）</span><span class="token comment" spellcheck="true">        #按后端服务器的响应时间来分配请求，响应时间短的优先分配。</span><span class="token comment" spellcheck="true">        #upstream backend {</span><span class="token comment" spellcheck="true">        #    server server1;</span><span class="token comment" spellcheck="true">        #    server server2;</span><span class="token comment" spellcheck="true">        #    fair;</span><span class="token comment" spellcheck="true">        #}</span><span class="token comment" spellcheck="true">        #4、url_hash（第三方）</span><span class="token comment" spellcheck="true">        #按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。</span><span class="token comment" spellcheck="true">        #例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法</span><span class="token comment" spellcheck="true">        #upstream backend {</span><span class="token comment" spellcheck="true">        #    server squid1:3128;</span><span class="token comment" spellcheck="true">        #    server squid2:3128;</span><span class="token comment" spellcheck="true">        #    hash $request_uri;</span><span class="token comment" spellcheck="true">        #    hash_method crc32;</span><span class="token comment" spellcheck="true">        #}</span><span class="token comment" spellcheck="true">        #tips:</span><span class="token comment" spellcheck="true">        #upstream bakend</span><span class="token comment" spellcheck="true">        #在需要使用负载均衡的server中增加 proxy_pass http://bakend/;</span><span class="token comment" spellcheck="true">        #每个设备的状态设置为:</span><span class="token comment" spellcheck="true">        #1.down表示单前的server暂时不参与负载</span><span class="token comment" spellcheck="true">        #2.weight为weight越大，负载的权重就越大。</span><span class="token comment" spellcheck="true">        #3.max_fails：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream模块定义的错误</span><span class="token comment" spellcheck="true">        #4.fail_timeout:max_fails次失败后，暂停的时间。</span><span class="token comment" spellcheck="true">        #5.backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。</span><span class="token comment" spellcheck="true">        #nginx支持同时设置多组的负载均衡，用来给不用的server来使用。</span><span class="token comment" spellcheck="true">        #client_body_in_file_only设置为On 可以讲client post过来的数据记录到文件中用来做debug</span><span class="token comment" spellcheck="true">        #client_body_temp_path设置记录文件的目录 可以设置最多3层目录</span><span class="token comment" spellcheck="true">        #location对URL进行匹配.可以进行重定向或者进行新的代理 负载均衡</span>    }<span class="token comment" spellcheck="true">    #虚拟主机的配置</span><span class="token attr-name">    server</span> <span class="token attr-value">{</span><span class="token comment" spellcheck="true">        #监听端口</span><span class="token attr-name">        listen</span> <span class="token attr-value">80;</span><span class="token comment" spellcheck="true">        #域名可以有多个，用空格隔开</span><span class="token attr-name">        server_name</span> <span class="token attr-value">www.jd.com jd.com;</span><span class="token comment" spellcheck="true">        #默认入口文件名称</span><span class="token attr-name">        index</span> <span class="token attr-value">index.html index.htm index.php;</span><span class="token attr-name">        root</span> <span class="token attr-value">/data/www/jd;</span><span class="token comment" spellcheck="true">        #对******进行负载均衡</span><span class="token attr-name">        location</span> <span class="token attr-value">~ .*.(php|php5)?$</span>        {<span class="token attr-name">            fastcgi_pass</span> <span class="token attr-value">127.0.0.1:9000;</span><span class="token attr-name">            fastcgi_index</span> <span class="token attr-value">index.php;</span><span class="token attr-name">            include</span> <span class="token attr-value">fastcgi.conf;</span>        }<span class="token comment" spellcheck="true">        #图片缓存时间设置</span><span class="token attr-name">        location</span> <span class="token attr-value">~ .*.(gif|jpg|jpeg|png|bmp|swf)$</span>        {<span class="token attr-name">            expires</span> <span class="token attr-value">10d;</span>        }<span class="token comment" spellcheck="true">        #JS和CSS缓存时间设置</span><span class="token attr-name">        location</span> <span class="token attr-value">~ .*.(js|css)?$</span>        {<span class="token attr-name">            expires</span> <span class="token attr-value">1h;</span>        }<span class="token comment" spellcheck="true">        #日志格式设定</span><span class="token comment" spellcheck="true">        #$remote_addr与$http_x_forwarded_for用以记录客户端的ip地址；</span><span class="token comment" spellcheck="true">        #$remote_user：用来记录客户端用户名称；</span><span class="token comment" spellcheck="true">        #$time_local： 用来记录访问时间与时区；</span><span class="token comment" spellcheck="true">        #$request： 用来记录请求的url与http协议；</span><span class="token comment" spellcheck="true">        #$status： 用来记录请求状态；成功是200，</span><span class="token comment" spellcheck="true">        #$body_bytes_sent ：记录发送给客户端文件主体内容大小；</span><span class="token comment" spellcheck="true">        #$http_referer：用来记录从那个页面链接访问过来的；</span><span class="token comment" spellcheck="true">        #$http_user_agent：记录客户浏览器的相关信息；</span><span class="token comment" spellcheck="true">        #通常web服务器放在反向代理的后面，这样就不能获取到客户的IP地址了，通过$remote_add拿到的IP地址是反向代理服务器的iP地址。反向代理服务器在转发请求的http头信息中，可以增加x_forwarded_for信息，用以记录原有客户端的IP地址和原来客户端的请求的服务器地址。</span><span class="token attr-name">        log_format</span> <span class="token attr-value">access '$remote_addr - $remote_user [$time_local] "$request" '</span><span class="token attr-name">        '$status</span> <span class="token attr-value">$body_bytes_sent "$http_referer" '</span><span class="token attr-name">        '"$http_user_agent"</span> <span class="token attr-value">$http_x_forwarded_for';</span><span class="token comment" spellcheck="true">        #定义本虚拟主机的访问日志</span><span class="token attr-name">        access_log</span> <span class="token attr-value"> /usr/local/nginx/logs/host.access.log  main;</span><span class="token attr-name">        access_log</span> <span class="token attr-value"> /usr/local/nginx/logs/host.access.404.log  log404;</span><span class="token comment" spellcheck="true">        #对 "/connect-controller" 启用反向代理</span><span class="token attr-name">        location</span> <span class="token attr-value">/connect-controller {</span><span class="token attr-name">            proxy_pass</span> <span class="token attr-value">http://127.0.0.1:88; #请注意此处端口号不能与虚拟主机监听的端口号一样（也就是server监听的端口）</span><span class="token attr-name">            proxy_redirect</span> <span class="token attr-value">off;</span><span class="token attr-name">            proxy_set_header</span> <span class="token attr-value">X-Real-IP $remote_addr;</span><span class="token comment" spellcheck="true">            #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP</span><span class="token attr-name">            proxy_set_header</span> <span class="token attr-value">X-Forwarded-For $proxy_add_x_forwarded_for;</span><span class="token comment" spellcheck="true">            #以下是一些反向代理的配置，可选。</span><span class="token attr-name">            proxy_set_header</span> <span class="token attr-value">Host $host;</span><span class="token comment" spellcheck="true">            #允许客户端请求的最大单文件字节数</span><span class="token attr-name">            client_max_body_size</span> <span class="token attr-value">10m;</span><span class="token comment" spellcheck="true">            #缓冲区代理缓冲用户端请求的最大字节数，</span><span class="token comment" spellcheck="true">            #如果把它设置为比较大的数值，例如256k，那么，无论使用firefox还是IE浏览器，来提交任意小于256k的图片，都很正常。如果注释该指令，使用默认的client_body_buffer_size设置，也就是操作系统页面大小的两倍，8k或者16k，问题就出现了。</span><span class="token comment" spellcheck="true">            #无论使用firefox4.0还是IE8.0，提交一个比较大，200k左右的图片，都返回500 Internal Server Error错误</span><span class="token attr-name">            client_body_buffer_size</span> <span class="token attr-value">128k;</span><span class="token comment" spellcheck="true">            #表示使nginx阻止HTTP应答代码为400或者更高的应答。</span><span class="token attr-name">            proxy_intercept_errors</span> <span class="token attr-value">on;</span><span class="token comment" spellcheck="true">            #后端服务器连接的超时时间_发起握手等候响应超时时间</span><span class="token comment" spellcheck="true">            #nginx跟后端服务器连接超时时间(代理连接超时)</span><span class="token attr-name">            proxy_connect_timeout</span> <span class="token attr-value">90;</span><span class="token comment" spellcheck="true">            #后端服务器数据回传时间(代理发送超时)</span><span class="token comment" spellcheck="true">            #后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据</span><span class="token attr-name">            proxy_send_timeout</span> <span class="token attr-value">90;</span><span class="token comment" spellcheck="true">            #连接成功后，后端服务器响应时间(代理接收超时)</span><span class="token comment" spellcheck="true">            #连接成功后_等候后端服务器响应时间_其实已经进入后端的排队之中等候处理（也可以说是后端服务器处理请求的时间）</span><span class="token attr-name">            proxy_read_timeout</span> <span class="token attr-value">90;</span><span class="token comment" spellcheck="true">            #设置代理服务器（nginx）保存用户头信息的缓冲区大小</span><span class="token comment" spellcheck="true">            #设置从被代理服务器读取的第一部分应答的缓冲区大小，通常情况下这部分应答中包含一个小的应答头，默认情况下这个值的大小为指令proxy_buffers中指定的一个缓冲区的大小，不过可以将其设置为更小</span><span class="token attr-name">            proxy_buffer_size</span> <span class="token attr-value">4k;</span><span class="token comment" spellcheck="true">            #proxy_buffers缓冲区，网页平均在32k以下的设置</span><span class="token comment" spellcheck="true">            #设置用于读取应答（来自被代理服务器）的缓冲区数目和大小，默认情况也为分页大小，根据操作系统的不同可能是4k或者8k</span><span class="token attr-name">            proxy_buffers</span> <span class="token attr-value">4 32k;</span><span class="token comment" spellcheck="true">            #高负荷下缓冲大小（proxy_buffers*2）</span><span class="token attr-name">            proxy_busy_buffers_size</span> <span class="token attr-value">64k;</span><span class="token comment" spellcheck="true">            #设置在写入proxy_temp_path时数据的大小，预防一个工作进程在传递文件时阻塞太长</span><span class="token comment" spellcheck="true">            #设定缓存文件夹大小，大于这个值，将从upstream服务器传</span><span class="token attr-name">            proxy_temp_file_write_size</span> <span class="token attr-value">64k;</span>        }<span class="token comment" spellcheck="true">        #本地动静分离反向代理配置</span><span class="token comment" spellcheck="true">        #所有jsp的页面均交由tomcat或resin处理</span><span class="token attr-name">        location</span> <span class="token attr-value">~ .(jsp|jspx|do)?$ {</span><span class="token attr-name">            proxy_set_header</span> <span class="token attr-value">Host $host;</span><span class="token attr-name">            proxy_set_header</span> <span class="token attr-value">X-Real-IP $remote_addr;</span><span class="token attr-name">            proxy_set_header</span> <span class="token attr-value">X-Forwarded-For $proxy_add_x_forwarded_for;</span><span class="token attr-name">            proxy_pass</span> <span class="token attr-value">http://127.0.0.1:8080;</span>        }    }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jenkins小记</title>
      <link href="/2019/09/11/zhuan-ye-pian/jenkins-xiao-ji/"/>
      <url>/2019/09/11/zhuan-ye-pian/jenkins-xiao-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="jenkins概念"><a href="#jenkins概念" class="headerlink" title="jenkins概念"></a>jenkins概念</h2><h3 id="持续集成、持续部署、持续交付"><a href="#持续集成、持续部署、持续交付" class="headerlink" title="持续集成、持续部署、持续交付"></a>持续集成、持续部署、持续交付</h3><p>更有利于迭代开发</p><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ul><li>降低风险</li><li>减少很多重复性工作</li></ul><h2 id="jenkins-svn"><a href="#jenkins-svn" class="headerlink" title="jenkins+svn"></a>jenkins+svn</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> jenkisn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git基本命令</title>
      <link href="/2019/09/06/zhuan-ye-pian/git-ji-ben-ming-ling/"/>
      <url>/2019/09/06/zhuan-ye-pian/git-ji-ben-ming-ling/</url>
      
        <content type="html"><![CDATA[<h2 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h2><ul><li>初始化本地仓库</li></ul><h2 id="git-config"><a href="#git-config" class="headerlink" title="git config"></a>git config</h2><ul><li>配置git全局信息<ul><li><code>$ git config --global user.name 'name'</code></li><li><code>$ git config --global user.email 'email'</code></li><li><code>$ git config --global core.quotepath false</code><ul><li>处理中文乱码问题</li></ul></li></ul></li></ul><h2 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h2><ul><li>添加指定文件：<ul><li><code>$ git add &lt;filename&gt;</code></li></ul></li><li>添加目录下所有文件<ul><li><code>$ git add .</code></li></ul></li></ul><h2 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h2><ul><li>删除添加的指定文件<ul><li><code>$ git rm --cached &lt;filename&gt;</code></li></ul></li></ul><h2 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h2><ul><li>查看添加的文件队列</li></ul><h2 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h2><ul><li>默认会弹出编辑日志框</li><li>直接指定日志内容提交<ul><li><code>$ git commit -m 'log'</code></li></ul></li></ul><h2 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h2><ul><li>添加远程仓库<ul><li><code>$ git remote add &lt;SSH URO or HTTP URL&gt;</code></li><li><code>$ git remote add origin remoteUrl</code></li></ul></li><li>查看绑定的远程仓库<ul><li><code>$ git remote -v</code></li><li><code>$ git remote remove &lt;remoteName&gt;</code></li><li><code>$ git remote remove origin</code></li></ul></li></ul><h2 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h2><ul><li>推送项目到远程仓库<ul><li><code>$ git push -u origin master</code></li></ul></li><li>强制提交<ul><li><code>$ git push origin master -f</code></li></ul></li></ul><h2 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h2><ul><li>从远程仓库拉取项目（同步）</li><li>将本地仓库和远程仓库进行关联<ul><li><code>$ git pull origin master --allow-unrelated-histories</code></li></ul></li></ul><h2 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h2><ul><li>从远程仓库拉取项目（从无到有）</li></ul><h2 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h2><ul><li>创建分支：test<ul><li><code>$ git branch test</code></li></ul></li></ul><h2 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h2><ul><li>切换到test分支<ul><li><code>$ git checkout test</code></li></ul></li></ul><h2 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h2><ul><li>合并test分支内容到主干<ul><li><code>$ git merge test</code></li><li><code>$ git merge --abort</code><ul><li>终止合并</li></ul></li><li><code>$ git reset --merge</code><ul><li>重新合并</li></ul></li><li><code>$ git pull</code><ul><li>重新拉取</li></ul></li></ul></li></ul><h2 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h2><ul><li>只是从远程获取最新版本到本地,不会merge(合并)</li></ul><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><ul><li>git checkout -b hello<ul><li>创建hello分支并切换到该分支</li></ul></li><li></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo基本命令</title>
      <link href="/2019/09/03/zhuan-ye-pian/hexo-ji-ben-ming-ling/"/>
      <url>/2019/09/03/zhuan-ye-pian/hexo-ji-ben-ming-ling/</url>
      
        <content type="html"><![CDATA[<h2 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h2><ul><li>安装hexo客户端</li><li><code>$ cnpm install hexo-cli -g</code></li></ul><h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><ul><li>创建hexo博客目录</li><li><code>$ hexo init [folder]</code></li></ul><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><p><code>$ hexo new [layout] &lt;title&gt;</code></p><ul><li>layout: 对应网站目录/scaffolds/下面的md文件对应的类型(md文件名)，该目录下存放的是模板文件</li></ul><table><thead><tr><th align="left">布局</th><th align="left">路径</th></tr></thead><tbody><tr><td align="left">draft</td><td align="left">source/_draft</td></tr><tr><td align="left">page</td><td align="left">source</td></tr><tr><td align="left">post</td><td align="left">source/_posts</td></tr></tbody></table><ul><li>hexo创建文件会根据这些模板文件进行文件生成</li></ul><h2 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h2><p><code>$ hexo publish [layout] &lt;title&gt;</code><br>发布草稿</p><h2 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h2><p><code>$ hexo generate</code><br>可以简写为:<br><code>$ hexo g</code><br>生成静态文件</p><h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><p><code>$ hexo server --debug --config local.yml</code></p><ul><li>-p,–post 重设端口</li><li>–debug   调试模式</li><li>–config  指定自定义配置文件启动</li></ul><h2 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h2><p><code>$ hexo deploy</code></p><ul><li>-g, –generate 部署前先生成静态文件</li></ul><h2 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h2><p><code>$ hexo clean</code></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown语法</title>
      <link href="/2019/08/31/zhuan-ye-pian/markdown-yu-fa/"/>
      <url>/2019/08/31/zhuan-ye-pian/markdown-yu-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><pre class=" language-markdown"><code class="language-markdown">代码<span class="token title important"><span class="token punctuation">##</span> 二级标题</span></code></pre><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><pre class=" language-markdown"><code class="language-markdown">代码<span class="token title important"><span class="token punctuation">###</span> 三级标题</span></code></pre><h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><ol><li>first</li><li>second</li><li>third</li></ol><pre class=" language-markdown"><code class="language-markdown">代码<span class="token list punctuation">1.</span> first<span class="token list punctuation">2.</span> second<span class="token list punctuation">3.</span> third</code></pre><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><ul><li>first</li><li>second</li><li>third</li></ul><pre class=" language-markdown"><code class="language-markdown">代码<span class="token list punctuation">-</span> first<span class="token list punctuation">-</span> second<span class="token list punctuation">-</span> third</code></pre><h2 id="链接写法"><a href="#链接写法" class="headerlink" title="链接写法"></a>链接写法</h2><p><a href="https://qqallnice.github.io/blog" target="_blank" rel="noopener">yw’s blog</a></p><pre class=" language-markdown"><code class="language-markdown">代码<span class="token url">[yw's blog](https://qqallnice.github.io/blog)</span></code></pre><h2 id="链接写法-带标题"><a href="#链接写法-带标题" class="headerlink" title="链接写法(带标题)"></a>链接写法(带标题)</h2><p><a href="https://qqallnice.github.io/blog" title="yw’s blog" target="_blank" rel="noopener">yw’s blog</a></p><pre class=" language-markdown"><code class="language-markdown">代码<span class="token url">[yw's blog](https://qqallnice.github.io/blog <span class="token string">"yw’s blog"</span>)</span></code></pre><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg" alt=""></p><pre class=" language-markdown"><code class="language-markdown">代码![](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg)</code></pre><h2 id="图片带title"><a href="#图片带title" class="headerlink" title="图片带title"></a>图片带title</h2><p><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg" alt="blockchain" title="区块链"></p><pre class=" language-markdown"><code class="language-markdown">代码<span class="token url">![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg <span class="token string">"区块链"</span>)</span></code></pre><h2 id="句子引用"><a href="#句子引用" class="headerlink" title="句子引用"></a>句子引用</h2><blockquote><p>balabalabalabalabalabalabalabala</p></blockquote><pre class=" language-markdown"><code class="language-markdown">代码<span class="token blockquote punctuation">></span> balabalabalabalabalabalabalabala</code></pre><h2 id="段落引用"><a href="#段落引用" class="headerlink" title="段落引用"></a>段落引用</h2><blockquote><p>balabalabalabalabalabalabalabala<br>balabalabalabalabalabalabalabala<br>balabalabalabalabalabalabalabala<br>balabalabalabalabalabalabalabala</p></blockquote><pre class=" language-markdown"><code class="language-markdown">代码<span class="token blockquote punctuation">></span> balabalabalabalabalabalabalabala<span class="token blockquote punctuation">></span> balabalabalabalabalabalabalabala<span class="token blockquote punctuation">></span> balabalabalabalabalabalabalabala<span class="token blockquote punctuation">></span> balabalabalabalabalabalabalabala</code></pre><h2 id="粗体"><a href="#粗体" class="headerlink" title="粗体"></a><strong>粗体</strong></h2><pre class=" language-markdown"><code class="language-markdown">代码<span class="token bold"><span class="token punctuation">**</span>粗体<span class="token punctuation">**</span></span>或者<span class="token bold"><span class="token punctuation">__</span>粗体<span class="token punctuation">__</span></span></code></pre><h2 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a><em>斜体</em></h2><pre class=" language-markdown"><code class="language-markdown">代码<span class="token italic"><span class="token punctuation">*</span>斜体<span class="token punctuation">*</span></span>或者<span class="token italic"><span class="token punctuation">_</span>斜体<span class="token punctuation">_</span></span></code></pre><h2 id="粗体-斜体"><a href="#粗体-斜体" class="headerlink" title="粗体+斜体"></a><strong><em>粗体+斜体</em></strong></h2><pre class=" language-markdown"><code class="language-markdown">代码<span class="token bold"><span class="token punctuation">**</span>*粗体+斜体<span class="token punctuation">**</span></span>*</code></pre><h2 id="废弃的文字"><a href="#废弃的文字" class="headerlink" title="废弃的文字"></a><del>废弃的文字</del></h2><pre class=" language-markdown"><code class="language-markdown">代码~~废弃的文字~~</code></pre><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><table><thead><tr><th>姓名</th><th>年龄</th><th align="center">三围</th></tr></thead><tbody><tr><td>张三</td><td>20</td><td align="center">12，21，21</td></tr><tr><td>张三</td><td>20</td><td align="center">12，21，21</td></tr><tr><td>张三</td><td>20</td><td align="center">12，21，21</td></tr></tbody></table><pre class=" language-markdown"><code class="language-markdown">代码| 姓名 | 年龄 | 三围 || --   |--- | :----: ||张三 | 20 |12，21，21||张三 | 20 |12，21，21||张三 | 20 |12，21，21|</code></pre><h2 id="代码行"><a href="#代码行" class="headerlink" title="代码行"></a>代码行</h2><p><code>hello world</code></p><pre class=" language-markdown"><code class="language-markdown">代码<span class="token code keyword">`hello world`</span></code></pre><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-markdown"><code class="language-markdown">代码```javaclass A{<span class="token code keyword">    public static void main(){</span><span class="token code keyword">        System.out.println("helloworld");</span><span class="token code keyword">    }</span>}```</code></pre><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><hr><pre class=" language-markdown"><code class="language-markdown">代码<span class="token hr punctuation">***</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
